{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rasterra","text":"<p>Documentation: https://collijk.github.io/rasterra</p> <p>Source Code: https://github.com/collijk/rasterra</p> <p>PyPI: https://pypi.org/project/rasterra/</p> <p>An in-memory object-oriented raster manipulation library.</p> <p><code>rasterra</code> is a library for manipulating raster data in memory. It is designed to be used in lieu of <code>rasterio</code> to allow for easier manipulation of raster data. It is designed to be used in conjunction with <code>geopandas</code> when vector data is also being used.</p> <p>Currently, <code>rasterra</code> is in a very early stage of development. It's primary limitation at this point is that it only supports single-band raster data. Multi-band support is planned for the near future.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install rasterra\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#file-io","title":"File I/O","text":"<p>Reading and writing raster data is done using the <code>load_raster</code> and <code>to_file</code> functions.</p> <pre><code>import rasterra as rt\n\n# Read in a raster\nraster = rt.load_raster(\"path/to/raster.tif\")\n\n# Write a raster to disk\nraster.to_file(\"path/to/output.tif\")\n</code></pre> <p>A raster can also be read and mosaic'd from multiple files using the <code>load_mf_raster</code> function.</p> <pre><code>import rasterra as rt\n\n# Read in a multi-file raster\nraster = rt.load_mf_raster([\"path/to/raster1.tif\", \"path/to/raster2.tif\"])\n</code></pre>"},{"location":"#raster-manipulation","title":"Raster Manipulation","text":"<p><code>rasterra</code> provides a number of methods for manipulating raster data. These methods are designed to be used in a method-chaining style, similar to <code>pandas</code> and <code>geopandas</code>.</p> <pre><code>import rasterra as rt\nimport geopandas as gpd\n\n# Read in a raster\nraster = rt.load_raster(\"path/to/raster.tif\")\nshapes = gpd.read_file(\"path/to/polygons.shp\")\n\n\nnew_raster = (\n    raster\n    .to_crs(shapes.crs)          # Reproject the raster to the same CRS as the polygons\n    .clip(shapes)                # Clip the raster to the bounding box of the polygons\n    .mask(shapes, fill_value=0)  # Mask the raster to the polygons, filling in areas outside the polygons with 0\n    .resample(0.5, 'sum')        # Downsample the raster half the original resolution,\n                                 # computing the area-weighted sum of the contributing pixels\n)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#063-2025-05-14","title":"0.6.3 - 2025-05-14","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Functionality to support loading metadata from a raster without loading the raster.</li> <li>Functionality to support loading a single raster band from a multi-band raster.</li> </ul>"},{"location":"changelog/#062-2025-02-26","title":"0.6.2 - 2025-02-26","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Additions to upgrade to poetry v2</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Relax python requirment to &gt;=3.12</li> </ul>"},{"location":"changelog/#061-2024-12-25","title":"0.6.1 - 2024-12-25","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support for a no-data color in plotting.</li> </ul>"},{"location":"changelog/#060-2024-08-28","title":"0.6.0 - 2024-08-28","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Added a <code>resolution</code> property to RasterArray that returns a tuple of     (x_resolution, y_resolution).</li> <li>Added a general purpose <code>reproject</code> method that can change the crs and resolution     simultaneously.</li> <li>Updated <code>resample</code>, <code>resample_to</code> and <code>to_crs</code> to use internal <code>reproject</code> method.</li> <li>Added a top level merge function to merge rasters in memory.</li> </ul>"},{"location":"changelog/#0514-2024-06-25","title":"0.5.14 - 2024-06-25","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Removed support for float128, which doesn't work on apple silicon.</li> </ul>"},{"location":"changelog/#0513-2024-06-24","title":"0.5.13 - 2024-06-24","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Upgrade numpy to 2.0</li> </ul>"},{"location":"changelog/#0512-2024-06-24","title":"0.5.12 - 2024-06-24","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Upgrade geopandas to 1.0</li> </ul>"},{"location":"changelog/#0511-2024-05-16","title":"0.5.11 - 2024-05-16","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Allow windowed reads of raster data.</li> <li>Add a selection method for extracting values from a raster array by coordinates.</li> </ul>"},{"location":"changelog/#0510-2024-05-15","title":"0.5.10 - 2024-05-15","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Accumulate and propagate the no-data mask through operations on RasterArray objects.</li> </ul>"},{"location":"changelog/#059-2024-05-10","title":"0.5.9 - 2024-05-10","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Add **kwargs to raster.to_file, allowing users to specify different drivers, compression,     tiling, and other options for writing raster files.</li> </ul>"},{"location":"changelog/#058-2024-05-10","title":"0.5.8 - 2024-05-10","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Basic import test</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Typing of flatiter in RasterArray</li> </ul>"},{"location":"changelog/#057-2024-05-08","title":"0.5.7 - 2024-05-08","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>More patches to the typing system.</li> </ul>"},{"location":"changelog/#056-2024-05-07","title":"0.5.6 - 2024-05-07","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Cover all float and int dtypes for RasterArray data.</li> </ul>"},{"location":"changelog/#055-2024-05-07","title":"0.5.5 - 2024-05-07","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>Updated dev tools to use ruff instead of black/isort/flake8 and friends</li> <li>Fixed a ton of typing and formatting picked up with the new tooling</li> <li>Explicitly export the RasterArray class and i/o methods in the <code>__init__.py</code> file</li> </ul>"},{"location":"changelog/#054-2024-05-07","title":"0.5.4 - 2024-05-07","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Fixed a bug with nodata call into rasterio.warp.resample</li> <li>Fixed implementation of x_coordinates and y_coordinates</li> <li>Fixed documentation build process</li> </ul>"},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>Added a getitem method to the RasterArray class</li> <li>Added a to_gdf method and backing function to convert raster data to vector data.</li> <li>Contributing guide and a better readme</li> </ul>"},{"location":"changelog/#052-2023-12-27","title":"0.5.2 - 2023-12-27","text":""},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>Doc build process</li> </ul>"},{"location":"changelog/#051-2023-12-27","title":"0.5.1 - 2023-12-27","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Fix documentation rendering.</li> </ul>"},{"location":"changelog/#050-2023-12-27","title":"0.5.0 - 2023-12-27","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Read rasters from one or many files</li> <li>Basic object-oriented raster object</li> <li>Sensible repr and basic plotting functions</li> <li>Numpy array interface</li> <li>Fixed up the CI for package maintenance, CI, and releases.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<ul> <li>Clone this repository</li> <li>Requirements:</li> <li>Poetry</li> <li>Python 3.10+</li> <li>Create a virtual environment and install the dependencies</li> </ul> <pre><code>poetry install\n</code></pre> <ul> <li>Activate the virtual environment</li> </ul> <pre><code>poetry shell\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<pre><code>pytest\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>The documentation is automatically generated from the content of the <code>docs</code> directory and from the docstrings  of the public signatures of the source code. The documentation is updated and published as a Github project page   automatically as part each release.</p>"},{"location":"contributing/#releasing","title":"Releasing","text":"<p>Trigger the Draft release workflow (press Run workflow). This will update the changelog &amp; version and create a GitHub release which is in Draft state.</p> <p>Find the draft release from the GitHub releases and publish it. When  a release is published, it'll trigger release workflow which creates PyPI  release and deploys updated documentation.</p>"},{"location":"contributing/#pre-commit","title":"Pre-commit","text":"<p>Pre-commit hooks run all the auto-formatters (e.g. <code>black</code>, <code>isort</code>), linters (e.g. <code>mypy</code>, <code>flake8</code>), and other quality  checks to make sure the changeset is in good shape before a commit/push happens.</p> <p>You can install the hooks with (runs for each commit):</p> <pre><code>pre-commit install\n</code></pre> <p>Or if you want them to run only for each push:</p> <pre><code>pre-commit install -t pre-push\n</code></pre> <p>Or if you want e.g. want to run all checks manually for all files:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>rasterra<ul> <li>_array</li> <li>_features</li> <li>_io</li> <li>_merge</li> <li>_plotting</li> <li>_typing</li> </ul> </li> </ul>"},{"location":"reference/rasterra/","title":"rasterra","text":""},{"location":"reference/rasterra/#rasterra.RasterArray","title":"<code>RasterArray</code>","text":"<p>               Bases: <code>NDArrayOperatorsMixin</code></p> Source code in <code>src/rasterra/_array.py</code> <pre><code>class RasterArray(np.lib.mixins.NDArrayOperatorsMixin):\n    def __init__(\n        self,\n        data: RasterData,\n        transform: Affine = _IDENTITY_TRANSFORM,\n        crs: RawCRS | None = None,\n        no_data_value: SupportedDtypes | None = NO_DATA_UNSET,\n    ):\n        \"\"\"\n        Initialize a RasterArray.\n\n        Parameters\n        ----------\n        data\n            2D NumPy array representing raster data.\n        transform\n            Affine transform to georeference the raster.\n        crs\n            Coordinate reference system.\n        no_data_value\n            Value representing no data.\n\n        \"\"\"\n        self._ndarray = data\n        self._transform = transform\n        if crs is not None and not isinstance(crs, CRS):\n            crs = CRS.from_user_input(crs)\n        self._crs: CRS | None = crs\n        self._no_data_value = no_data_value\n\n    # ----------------------------------------------------------------\n    # Array data\n\n    @property\n    def flags(self) -&gt; flagsobj:\n        \"\"\"Flags of the raster.\"\"\"\n        return self._ndarray.flags\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"Shape of the raster.\"\"\"\n        return self._ndarray.shape\n\n    @property\n    def strides(self) -&gt; tuple[int, ...]:\n        \"\"\"Strides of the raster.\"\"\"\n        return self._ndarray.strides\n\n    @property\n    def ndim(self) -&gt; int:\n        \"\"\"Number of dimensions of the raster.\"\"\"\n        return 2\n\n    @property\n    def data(self) -&gt; memoryview:\n        \"\"\"Python buffer object pooint to the start of the raster's data.\"\"\"\n        return self._ndarray.data\n\n    @property\n    def size(self) -&gt; int:\n        \"\"\"Number of elements in the raster.\"\"\"\n        return self._ndarray.size\n\n    @property\n    def itemsize(self) -&gt; int:\n        \"\"\"Size of each element in the raster.\"\"\"\n        return self._ndarray.itemsize\n\n    @property\n    def nbytes(self) -&gt; int:\n        \"\"\"Number of bytes in the raster.\"\"\"\n        return self._ndarray.nbytes\n\n    @property\n    def base(self) -&gt; RasterData | None:\n        \"\"\"Base object of the raster.\"\"\"\n        return self._ndarray.base\n\n    @property\n    def dtype(self) -&gt; np.dtype[DataDtypes]:\n        \"\"\"Data type of the raster.\"\"\"\n        return self._ndarray.dtype\n\n    @property\n    def T(self) -&gt; typing.NoReturn:  # noqa: N802\n        \"\"\"Transpose of the raster.\"\"\"\n        msg = \"Transpose of a raster is not defined.\"\n        raise TypeError(msg)\n\n    @property\n    def real(self) -&gt; typing.NoReturn:\n        \"\"\"Real part of the raster.\"\"\"\n        msg = \"Complex raster data is not supported.\"\n        raise NotImplementedError(msg)\n\n    @property\n    def imag(self) -&gt; typing.NoReturn:\n        \"\"\"Imaginary part of the raster.\"\"\"\n        msg = \"Complex raster data is not supported.\"\n        raise NotImplementedError(msg)\n\n    @property\n    def flat(self) -&gt; np.flatiter:  # type: ignore[type-arg]\n        \"\"\"Flat iterator of the raster.\"\"\"\n        return self._ndarray.flat\n\n    @property\n    def ctypes(self) -&gt; typing.NoReturn:\n        \"\"\"ctypes object of the raster.\"\"\"\n        msg = \"ctypes object of a raster is not defined.\"\n        raise TypeError(msg)\n\n    def __getitem__(self, item: int | slice | tuple[int, int] | tuple[slice, slice]):  # type: ignore[no-untyped-def]\n        def _process_item(_item: int | slice) -&gt; int | slice:\n            if isinstance(_item, int):\n                return _item\n            elif isinstance(_item, slice):\n                if _item.step is not None:\n                    msg = \"Slicing with a step is not supported.\"\n                    raise ValueError(msg)\n                return _item.start or 0\n            else:\n                msg = \"Invalid index type\"\n                raise TypeError(msg)\n\n        new_data = self._ndarray[item]\n        if not isinstance(new_data, np.ndarray):\n            return new_data\n\n        if isinstance(item, tuple):\n            if len(item) != 2:  # noqa: PLR2004\n                msg = \"Invalid number of indices\"\n                raise ValueError(msg)\n            y_item, x_item = item\n\n            yi = _process_item(y_item)\n            xi = _process_item(x_item)\n        else:\n            yi = _process_item(item)\n            xi = 0\n\n        new_transform = Affine(\n            self._transform.a,\n            self._transform.b,\n            self._transform.c + xi * self._transform.a,\n            self._transform.d,\n            self._transform.e,\n            self._transform.f + yi * self._transform.e,\n        )\n\n        return RasterArray(new_data, new_transform, self._crs, self._no_data_value)\n\n    # ----------------------------------------------------------------\n    # NumPy array interface\n\n    def astype(self, dtype: type[DataDtypes]) -&gt; \"RasterArray\":\n        \"\"\"Cast the raster to a new data type.\"\"\"\n        return RasterArray(\n            self._ndarray.astype(dtype), self._transform, self._crs, self._no_data_value\n        )\n\n    def to_numpy(self) -&gt; RasterData:\n        \"\"\"Convert the raster to a NumPy array.\"\"\"\n        return self._ndarray.copy()\n\n    def __array__(self, dtype: type[DataDtypes] | None = None) -&gt; RasterData:\n        return np.asarray(self._ndarray, dtype=dtype)\n\n    def __array_ufunc__(  # noqa: C901\n        self,\n        ufunc: np.ufunc,\n        method: NumpyUFuncMethod,\n        *inputs: typing.Union[RasterData, SupportedDtypes, \"RasterArray\"],\n        **kwargs: typing.Any,\n    ) -&gt; typing.Union[tuple[\"RasterArray\", ...], \"RasterArray\"]:\n        out = kwargs.get(\"out\", ())\n        for x in inputs + out:\n            # Only support operations with instances of _HANDLED_TYPES.\n            # Use RasterArray instead of type(self) for isinstance to\n            # allow subclasses that don't override __array_ufunc__ to\n            # handle RasterArray objects.\n            handled_types = (np.ndarray, numbers.Number, RasterArray)\n            if not isinstance(x, handled_types):\n                return NotImplemented  # type: ignore[no-any-return]\n            if isinstance(x, RasterArray):\n                if x._crs != self._crs:  # noqa: SLF001\n                    msg = \"Coordinate reference systems do not match.\"\n                    raise ValueError(msg)\n                if not self._no_data_equal(x._no_data_value):  # noqa: SLF001\n                    msg = \"No data values do not match.\"\n                    raise ValueError(msg)\n                if x._transform != self._transform:  # noqa: SLF001\n                    msg = \"Affine transforms do not match.\"\n                    raise ValueError(msg)\n\n        # Propagate the no_data_value to the output array.\n        no_data_mask = self.no_data_mask\n        for x in inputs:\n            if isinstance(x, RasterArray):\n                no_data_mask |= x.no_data_mask\n\n        # Defer to the implementation of the ufunc on unwrapped values.\n        inputs = tuple(x._ndarray if isinstance(x, RasterArray) else x for x in inputs)  # noqa: SLF001\n        if out:\n            kwargs[\"out\"] = tuple(\n                x._ndarray if isinstance(x, RasterArray) else x  # noqa: SLF001\n                for x in out\n            )\n        result = getattr(ufunc, method)(*inputs, **kwargs)\n        result[no_data_mask] = self._no_data_value\n\n        if type(result) is tuple:\n            # multiple return values\n            return tuple(\n                type(self)(x, self._transform, self._crs, self._no_data_value)\n                for x in result\n            )\n        else:\n            # one return value\n            return type(self)(result, self._transform, self._crs, self._no_data_value)\n\n    # ----------------------------------------------------------------\n    # Specialized array methods\n\n    def all(self) -&gt; bool:\n        \"\"\"Return True if all elements evaluate to True.\"\"\"\n        return self._ndarray.all()  # type: ignore[return-value]\n\n    def any(self) -&gt; bool:\n        \"\"\"Return True if any element evaluates to True.\"\"\"\n        return self._ndarray.any()  # type: ignore[return-value]\n\n    # ----------------------------------------------------------------\n    # Raster data\n\n    @property\n    def transform(self) -&gt; Affine:\n        \"\"\"Affine transform to georeference the raster.\"\"\"\n        return self._transform\n\n    @property\n    def x_min(self) -&gt; float:\n        \"\"\"Minimum x coordinate.\"\"\"\n        return self.transform.c  # type: ignore[no-any-return]\n\n    @property\n    def x_max(self) -&gt; float:\n        \"\"\"Maximum x coordinate.\"\"\"\n        return self.x_min + self.x_resolution * self.width\n\n    @property\n    def y_min(self) -&gt; float:\n        \"\"\"Minimum y coordinate.\"\"\"\n        return self.y_max + self.y_resolution * self.height\n\n    @property\n    def y_max(self) -&gt; float:\n        \"\"\"Maximum y coordinate.\"\"\"\n        return self.transform.f  # type: ignore[no-any-return]\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Width of the raster.\"\"\"\n        return self._ndarray.shape[1]\n\n    @property\n    def height(self) -&gt; int:\n        \"\"\"Height of the raster.\"\"\"\n        return self._ndarray.shape[0]\n\n    @property\n    def x_resolution(self) -&gt; float:\n        \"\"\"Resolution in x direction.\"\"\"\n        return self.transform.a  # type: ignore[no-any-return]\n\n    @property\n    def y_resolution(self) -&gt; float:\n        \"\"\"Resolution in y direction.\"\"\"\n        return self.transform.e  # type: ignore[no-any-return]\n\n    @property\n    def resolution(self) -&gt; tuple[float, float]:\n        \"\"\"Resolution in x and y directions.\"\"\"\n        return self.x_resolution, self.y_resolution\n\n    def x_coordinates(\n        self, *, center: bool = False\n    ) -&gt; npt.NDArray[np.floating[typing.Any]]:\n        \"\"\"x coordinates of the raster.\"\"\"\n        if center:\n            return np.linspace(\n                self.x_min + self.x_resolution / 2,\n                self.x_max - self.x_resolution / 2,\n                self.width,\n            )\n        else:\n            return np.linspace(\n                self.x_min,\n                self.x_max - self.x_resolution,\n                self.width,\n            )\n\n    def y_coordinates(\n        self, *, center: bool = False\n    ) -&gt; npt.NDArray[np.floating[typing.Any]]:\n        \"\"\"y coordinates of the raster.\"\"\"\n        if center:\n            return np.linspace(\n                self.y_min - self.y_resolution / 2,\n                self.y_max + self.y_resolution / 2,\n                self.height,\n            )\n        else:\n            return np.linspace(\n                self.y_min - self.y_resolution,\n                self.y_max,\n                self.height,\n            )\n\n    @property\n    def bounds(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"Bounding box of the raster.\"\"\"\n        return self.x_min, self.x_max, self.y_min, self.y_max\n\n    @property\n    def crs(self) -&gt; str | None:\n        \"\"\"Coordinate reference system.\"\"\"\n        if isinstance(self._crs, CRS):\n            return self._crs.to_string()  # type: ignore[no-any-return]\n        else:\n            return self._crs\n\n    def set_crs(self, new_crs: RawCRS) -&gt; \"RasterArray\":\n        if self._crs is not None:\n            msg = (\n                \"Coordinate reference system is already set. Use to_crs() to reproject \"\n                \"to a new coordinate reference system.\"\n            )\n            raise ValueError(msg)\n        return RasterArray(\n            self._ndarray.copy(), self._transform, new_crs, self._no_data_value\n        )\n\n    def to_crs(self, new_crs: str, resampling: str = \"nearest\") -&gt; \"RasterArray\":\n        \"\"\"Reproject the raster to a new coordinate reference system.\"\"\"\n        if self._crs is None:\n            msg = \"Coordinate reference system is not set.\"\n            raise ValueError(msg)\n        return self.reproject(\n            dst_crs=new_crs,\n            resampling=resampling,\n        )\n\n    @property\n    def no_data_value(self) -&gt; SupportedDtypes:\n        \"\"\"Value representing no data.\"\"\"\n        if self._no_data_value is NO_DATA_UNSET:\n            msg = \"No data value is not set.\"\n            raise ValueError(msg)\n        return self._no_data_value\n\n    def set_no_data_value(self, new_no_data_value: SupportedDtypes) -&gt; \"RasterArray\":\n        new_data = self._ndarray.copy()\n        if self._no_data_value is not NO_DATA_UNSET:\n            new_data[self.no_data_mask] = new_no_data_value\n        return RasterArray(new_data, self._transform, self._crs, new_no_data_value)\n\n    def _no_data_equal(self, other_no_data_value: SupportedDtypes | None) -&gt; bool:\n        if self._no_data_value is NO_DATA_UNSET:\n            return other_no_data_value is NO_DATA_UNSET\n        elif other_no_data_value is NO_DATA_UNSET:\n            return False\n        elif np.isnan(self._no_data_value):\n            return np.isnan(other_no_data_value)  # type: ignore[no-any-return]\n        elif np.isinf(self._no_data_value):\n            other_inf = np.isinf(other_no_data_value)\n            sign_match = np.sign(self._no_data_value) == np.sign(other_no_data_value)\n            return other_inf and sign_match  # type: ignore[no-any-return]\n        else:\n            return self._no_data_value == other_no_data_value\n\n    def unset_no_data_value(self) -&gt; \"RasterArray\":\n        \"\"\"Unset value representing no data.\"\"\"\n        return RasterArray(\n            self._ndarray.copy(), self._transform, self._crs, NO_DATA_UNSET\n        )\n\n    @property\n    def no_data_mask(self) -&gt; RasterMask:\n        \"\"\"Mask representing no data.\"\"\"\n        if self._no_data_value is NO_DATA_UNSET:\n            return np.zeros_like(self._ndarray, dtype=bool)\n        elif np.isnan(self._no_data_value):\n            return np.isnan(self._ndarray)\n        elif np.isinf(self._no_data_value):\n            return np.isinf(self._ndarray)\n        else:\n            return np.equal(self._ndarray, self._no_data_value)\n\n    def resample(self, scale: float, resampling: str = \"nearest\") -&gt; \"RasterArray\":\n        \"\"\"Resample the raster.\"\"\"\n        dest_width = int(self.width * scale)\n        dest_height = int(self.height * scale)\n        destination = np.empty((dest_height, dest_width), dtype=self._ndarray.dtype)\n        return self.reproject(\n            destination=destination,\n            dst_crs=self._crs,\n            resampling=resampling,\n        )\n\n    def resample_to(\n        self, target: \"RasterArray\", resampling: str = \"nearest\"\n    ) -&gt; \"RasterArray\":\n        \"\"\"Resample the raster to match the resolution of another raster.\"\"\"\n        destination = np.empty_like(target._ndarray, dtype=self._ndarray.dtype)  # noqa: SLF001\n        return self.reproject(\n            destination=destination,\n            dst_transform=target.transform,\n            dst_crs=target._crs,  # noqa: SLF001\n            resampling=resampling,\n        )\n\n    def reproject(\n        self,\n        destination: RasterData | None = None,\n        dst_transform: Affine | None = None,\n        dst_resolution: float | tuple[float, float] | None = None,\n        dst_crs: RawCRS | None = None,\n        resampling: str = \"nearest\",\n    ) -&gt; \"RasterArray\":\n        \"\"\"Reproject the raster to match the resolution of another raster.\"\"\"\n        resampling = _RESAMPLING_MAP[resampling]\n\n        dst_crs = self._crs if dst_crs is None else CRS.from_user_input(dst_crs)\n        new_data, transform = reproject(\n            source=self._ndarray,\n            src_transform=self._transform,\n            src_crs=self._crs,\n            src_nodata=self._no_data_value,\n            destination=destination,\n            dst_transform=dst_transform,\n            dst_resolution=dst_resolution,\n            dst_crs=dst_crs,\n            resampling=resampling,\n        )\n        if len(new_data.shape) == 3:  # noqa: PLR2004\n            # Some operations assume and prepend a channel dimension\n            new_data = new_data[0]\n        return RasterArray(\n            new_data,\n            transform,\n            dst_crs,\n            self.no_data_value,\n        )\n\n    def _coerce_to_shapely(\n        self, shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries\n    ) -&gt; Polygon | MultiPolygon:\n        if isinstance(shape, (gpd.GeoDataFrame, gpd.GeoSeries)):\n            if shape.crs != self._crs:\n                msg = \"Coordinate reference systems do not match.\"\n                raise ValueError(msg)\n            return shape.geometry.unary_union\n        return shape\n\n    def clip(\n        self, shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries\n    ) -&gt; \"RasterArray\":\n        \"\"\"Clip the raster to a shape.\"\"\"\n        shape = self._coerce_to_shapely(shape)\n        _, transform, window = raster_geometry_mask(\n            data_transform=self.transform,\n            data_width=self._ndarray.shape[1],\n            data_height=self._ndarray.shape[0],\n            shapes=[shape],\n            crop=True,\n        )\n\n        x_start, x_end = window.col_off, window.col_off + window.width\n        y_start, y_end = window.row_off, window.row_off + window.height\n        new_data = self._ndarray[y_start:y_end, x_start:x_end].copy()\n        return RasterArray(\n            new_data, transform, self._crs, no_data_value=self.no_data_value\n        )\n\n    def mask(\n        self,\n        shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries,\n        *,\n        fill_value: SupportedDtypes | None = None,\n        all_touched: bool = False,\n        invert: bool = False,\n    ) -&gt; \"RasterArray\":\n        \"\"\"Mask the raster with a shape.\"\"\"\n        shape = self._coerce_to_shapely(shape)\n        if fill_value is None and self._no_data_value is NO_DATA_UNSET:\n            msg = \"No fill value is set.\"\n            raise ValueError(msg)\n\n        if fill_value is None:\n            fill_value = self.no_data_value\n\n        shape_mask, *_ = raster_geometry_mask(\n            data_transform=self.transform,\n            data_width=self._ndarray.shape[1],\n            data_height=self._ndarray.shape[0],\n            shapes=[shape],\n            all_touched=all_touched,\n            invert=invert,\n        )\n        new_data = self._ndarray.copy()\n        new_data[shape_mask] = fill_value\n\n        return RasterArray(\n            new_data, self.transform, self._crs, no_data_value=self.no_data_value\n        )\n\n    def select(\n        self,\n        x_coordinates: npt.NDArray[np.float64],\n        y_coordinates: npt.NDArray[np.float64],\n        method: str = \"nearest\",\n    ) -&gt; npt.NDArray[DataDtypes]:\n        \"\"\"Select values at specific coordinates.\"\"\"\n        if x_coordinates.size != y_coordinates.size:\n            msg = \"x and y coordinates must have the same size.\"\n            raise ValueError(msg)\n\n        if method == \"nearest\":\n            x_indices = np.clip(\n                np.searchsorted(self.x_coordinates(), x_coordinates),\n                0,\n                self.width - 1,\n            )\n            y_indices = np.searchsorted(\n                self.y_coordinates(), y_coordinates, side=\"right\"\n            )\n            # Flip y indices to match raster coordinatesok\n            y_indices = np.clip(\n                self.height - y_indices,\n                0,\n                self.height - 1,\n            )\n\n            return self._ndarray[y_indices, x_indices].copy()\n        else:\n            msg = \"Only 'nearest' method is supported.\"\n            raise NotImplementedError(msg)\n\n    def __repr__(self) -&gt; str:\n        out = \"RasterArray\\n\"\n        out += \"===========\\n\"\n        out += f\"dimensions    : {self.width}, {self.height} (x, y)\\n\"\n        out += f\"resolution    : {self.transform.a}, {self.transform.e} (x, y)\\n\"\n        bounds = \", \".join(\n            str(s) for s in [self.x_min, self.x_max, self.y_min, self.y_max]\n        )\n        out += f\"extent        : {bounds} (xmin, xmax, ymin, ymax)\\n\"\n        out += f\"crs           : {self.crs}\\n\"\n        out += f\"no_data_value : {self._no_data_value}\\n\"\n        out += f\"size          : {self.nbytes / 1024**2:.2f} MB\\n\"\n        out += f\"dtype         : {self._ndarray.dtype}\\n\"\n        return out\n\n    def to_file(self, path: FilePath, **kwargs: typing.Any) -&gt; None:\n        \"\"\"Write the raster to a file.\"\"\"\n        from rasterra._io import write_raster\n\n        write_raster(self, path, **kwargs)\n\n    def to_gdf(self) -&gt; gpd.GeoDataFrame:\n        return to_gdf(self)\n\n    @property\n    def plot(self) -&gt; Plotter:\n        return Plotter(self._ndarray, self.no_data_mask, self.transform)\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.T","title":"<code>T: typing.NoReturn</code>  <code>property</code>","text":"<p>Transpose of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.base","title":"<code>base: RasterData | None</code>  <code>property</code>","text":"<p>Base object of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.bounds","title":"<code>bounds: tuple[float, float, float, float]</code>  <code>property</code>","text":"<p>Bounding box of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.crs","title":"<code>crs: str | None</code>  <code>property</code>","text":"<p>Coordinate reference system.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.ctypes","title":"<code>ctypes: typing.NoReturn</code>  <code>property</code>","text":"<p>ctypes object of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.data","title":"<code>data: memoryview</code>  <code>property</code>","text":"<p>Python buffer object pooint to the start of the raster's data.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.dtype","title":"<code>dtype: np.dtype[DataDtypes]</code>  <code>property</code>","text":"<p>Data type of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.flags","title":"<code>flags: flagsobj</code>  <code>property</code>","text":"<p>Flags of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.flat","title":"<code>flat: np.flatiter</code>  <code>property</code>","text":"<p>Flat iterator of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.height","title":"<code>height: int</code>  <code>property</code>","text":"<p>Height of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.imag","title":"<code>imag: typing.NoReturn</code>  <code>property</code>","text":"<p>Imaginary part of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.itemsize","title":"<code>itemsize: int</code>  <code>property</code>","text":"<p>Size of each element in the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.nbytes","title":"<code>nbytes: int</code>  <code>property</code>","text":"<p>Number of bytes in the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.ndim","title":"<code>ndim: int</code>  <code>property</code>","text":"<p>Number of dimensions of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.no_data_mask","title":"<code>no_data_mask: RasterMask</code>  <code>property</code>","text":"<p>Mask representing no data.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.no_data_value","title":"<code>no_data_value: SupportedDtypes</code>  <code>property</code>","text":"<p>Value representing no data.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.real","title":"<code>real: typing.NoReturn</code>  <code>property</code>","text":"<p>Real part of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.resolution","title":"<code>resolution: tuple[float, float]</code>  <code>property</code>","text":"<p>Resolution in x and y directions.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.shape","title":"<code>shape: tuple[int, ...]</code>  <code>property</code>","text":"<p>Shape of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.size","title":"<code>size: int</code>  <code>property</code>","text":"<p>Number of elements in the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.strides","title":"<code>strides: tuple[int, ...]</code>  <code>property</code>","text":"<p>Strides of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.transform","title":"<code>transform: Affine</code>  <code>property</code>","text":"<p>Affine transform to georeference the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.width","title":"<code>width: int</code>  <code>property</code>","text":"<p>Width of the raster.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.x_max","title":"<code>x_max: float</code>  <code>property</code>","text":"<p>Maximum x coordinate.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.x_min","title":"<code>x_min: float</code>  <code>property</code>","text":"<p>Minimum x coordinate.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.x_resolution","title":"<code>x_resolution: float</code>  <code>property</code>","text":"<p>Resolution in x direction.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.y_max","title":"<code>y_max: float</code>  <code>property</code>","text":"<p>Maximum y coordinate.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.y_min","title":"<code>y_min: float</code>  <code>property</code>","text":"<p>Minimum y coordinate.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.y_resolution","title":"<code>y_resolution: float</code>  <code>property</code>","text":"<p>Resolution in y direction.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.__init__","title":"<code>__init__(data: RasterData, transform: Affine = _IDENTITY_TRANSFORM, crs: RawCRS | None = None, no_data_value: SupportedDtypes | None = NO_DATA_UNSET)</code>","text":"<p>Initialize a RasterArray.</p>"},{"location":"reference/rasterra/#rasterra.RasterArray.__init__--parameters","title":"Parameters","text":"<p>data     2D NumPy array representing raster data. transform     Affine transform to georeference the raster. crs     Coordinate reference system. no_data_value     Value representing no data.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def __init__(\n    self,\n    data: RasterData,\n    transform: Affine = _IDENTITY_TRANSFORM,\n    crs: RawCRS | None = None,\n    no_data_value: SupportedDtypes | None = NO_DATA_UNSET,\n):\n    \"\"\"\n    Initialize a RasterArray.\n\n    Parameters\n    ----------\n    data\n        2D NumPy array representing raster data.\n    transform\n        Affine transform to georeference the raster.\n    crs\n        Coordinate reference system.\n    no_data_value\n        Value representing no data.\n\n    \"\"\"\n    self._ndarray = data\n    self._transform = transform\n    if crs is not None and not isinstance(crs, CRS):\n        crs = CRS.from_user_input(crs)\n    self._crs: CRS | None = crs\n    self._no_data_value = no_data_value\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.all","title":"<code>all() -&gt; bool</code>","text":"<p>Return True if all elements evaluate to True.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def all(self) -&gt; bool:\n    \"\"\"Return True if all elements evaluate to True.\"\"\"\n    return self._ndarray.all()  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.any","title":"<code>any() -&gt; bool</code>","text":"<p>Return True if any element evaluates to True.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def any(self) -&gt; bool:\n    \"\"\"Return True if any element evaluates to True.\"\"\"\n    return self._ndarray.any()  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.astype","title":"<code>astype(dtype: type[DataDtypes]) -&gt; RasterArray</code>","text":"<p>Cast the raster to a new data type.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def astype(self, dtype: type[DataDtypes]) -&gt; \"RasterArray\":\n    \"\"\"Cast the raster to a new data type.\"\"\"\n    return RasterArray(\n        self._ndarray.astype(dtype), self._transform, self._crs, self._no_data_value\n    )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.clip","title":"<code>clip(shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries) -&gt; RasterArray</code>","text":"<p>Clip the raster to a shape.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def clip(\n    self, shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries\n) -&gt; \"RasterArray\":\n    \"\"\"Clip the raster to a shape.\"\"\"\n    shape = self._coerce_to_shapely(shape)\n    _, transform, window = raster_geometry_mask(\n        data_transform=self.transform,\n        data_width=self._ndarray.shape[1],\n        data_height=self._ndarray.shape[0],\n        shapes=[shape],\n        crop=True,\n    )\n\n    x_start, x_end = window.col_off, window.col_off + window.width\n    y_start, y_end = window.row_off, window.row_off + window.height\n    new_data = self._ndarray[y_start:y_end, x_start:x_end].copy()\n    return RasterArray(\n        new_data, transform, self._crs, no_data_value=self.no_data_value\n    )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.mask","title":"<code>mask(shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries, *, fill_value: SupportedDtypes | None = None, all_touched: bool = False, invert: bool = False) -&gt; RasterArray</code>","text":"<p>Mask the raster with a shape.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def mask(\n    self,\n    shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries,\n    *,\n    fill_value: SupportedDtypes | None = None,\n    all_touched: bool = False,\n    invert: bool = False,\n) -&gt; \"RasterArray\":\n    \"\"\"Mask the raster with a shape.\"\"\"\n    shape = self._coerce_to_shapely(shape)\n    if fill_value is None and self._no_data_value is NO_DATA_UNSET:\n        msg = \"No fill value is set.\"\n        raise ValueError(msg)\n\n    if fill_value is None:\n        fill_value = self.no_data_value\n\n    shape_mask, *_ = raster_geometry_mask(\n        data_transform=self.transform,\n        data_width=self._ndarray.shape[1],\n        data_height=self._ndarray.shape[0],\n        shapes=[shape],\n        all_touched=all_touched,\n        invert=invert,\n    )\n    new_data = self._ndarray.copy()\n    new_data[shape_mask] = fill_value\n\n    return RasterArray(\n        new_data, self.transform, self._crs, no_data_value=self.no_data_value\n    )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.reproject","title":"<code>reproject(destination: RasterData | None = None, dst_transform: Affine | None = None, dst_resolution: float | tuple[float, float] | None = None, dst_crs: RawCRS | None = None, resampling: str = 'nearest') -&gt; RasterArray</code>","text":"<p>Reproject the raster to match the resolution of another raster.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def reproject(\n    self,\n    destination: RasterData | None = None,\n    dst_transform: Affine | None = None,\n    dst_resolution: float | tuple[float, float] | None = None,\n    dst_crs: RawCRS | None = None,\n    resampling: str = \"nearest\",\n) -&gt; \"RasterArray\":\n    \"\"\"Reproject the raster to match the resolution of another raster.\"\"\"\n    resampling = _RESAMPLING_MAP[resampling]\n\n    dst_crs = self._crs if dst_crs is None else CRS.from_user_input(dst_crs)\n    new_data, transform = reproject(\n        source=self._ndarray,\n        src_transform=self._transform,\n        src_crs=self._crs,\n        src_nodata=self._no_data_value,\n        destination=destination,\n        dst_transform=dst_transform,\n        dst_resolution=dst_resolution,\n        dst_crs=dst_crs,\n        resampling=resampling,\n    )\n    if len(new_data.shape) == 3:  # noqa: PLR2004\n        # Some operations assume and prepend a channel dimension\n        new_data = new_data[0]\n    return RasterArray(\n        new_data,\n        transform,\n        dst_crs,\n        self.no_data_value,\n    )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.resample","title":"<code>resample(scale: float, resampling: str = 'nearest') -&gt; RasterArray</code>","text":"<p>Resample the raster.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def resample(self, scale: float, resampling: str = \"nearest\") -&gt; \"RasterArray\":\n    \"\"\"Resample the raster.\"\"\"\n    dest_width = int(self.width * scale)\n    dest_height = int(self.height * scale)\n    destination = np.empty((dest_height, dest_width), dtype=self._ndarray.dtype)\n    return self.reproject(\n        destination=destination,\n        dst_crs=self._crs,\n        resampling=resampling,\n    )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.resample_to","title":"<code>resample_to(target: RasterArray, resampling: str = 'nearest') -&gt; RasterArray</code>","text":"<p>Resample the raster to match the resolution of another raster.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def resample_to(\n    self, target: \"RasterArray\", resampling: str = \"nearest\"\n) -&gt; \"RasterArray\":\n    \"\"\"Resample the raster to match the resolution of another raster.\"\"\"\n    destination = np.empty_like(target._ndarray, dtype=self._ndarray.dtype)  # noqa: SLF001\n    return self.reproject(\n        destination=destination,\n        dst_transform=target.transform,\n        dst_crs=target._crs,  # noqa: SLF001\n        resampling=resampling,\n    )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.select","title":"<code>select(x_coordinates: npt.NDArray[np.float64], y_coordinates: npt.NDArray[np.float64], method: str = 'nearest') -&gt; npt.NDArray[DataDtypes]</code>","text":"<p>Select values at specific coordinates.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def select(\n    self,\n    x_coordinates: npt.NDArray[np.float64],\n    y_coordinates: npt.NDArray[np.float64],\n    method: str = \"nearest\",\n) -&gt; npt.NDArray[DataDtypes]:\n    \"\"\"Select values at specific coordinates.\"\"\"\n    if x_coordinates.size != y_coordinates.size:\n        msg = \"x and y coordinates must have the same size.\"\n        raise ValueError(msg)\n\n    if method == \"nearest\":\n        x_indices = np.clip(\n            np.searchsorted(self.x_coordinates(), x_coordinates),\n            0,\n            self.width - 1,\n        )\n        y_indices = np.searchsorted(\n            self.y_coordinates(), y_coordinates, side=\"right\"\n        )\n        # Flip y indices to match raster coordinatesok\n        y_indices = np.clip(\n            self.height - y_indices,\n            0,\n            self.height - 1,\n        )\n\n        return self._ndarray[y_indices, x_indices].copy()\n    else:\n        msg = \"Only 'nearest' method is supported.\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.to_crs","title":"<code>to_crs(new_crs: str, resampling: str = 'nearest') -&gt; RasterArray</code>","text":"<p>Reproject the raster to a new coordinate reference system.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def to_crs(self, new_crs: str, resampling: str = \"nearest\") -&gt; \"RasterArray\":\n    \"\"\"Reproject the raster to a new coordinate reference system.\"\"\"\n    if self._crs is None:\n        msg = \"Coordinate reference system is not set.\"\n        raise ValueError(msg)\n    return self.reproject(\n        dst_crs=new_crs,\n        resampling=resampling,\n    )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.to_file","title":"<code>to_file(path: FilePath, **kwargs: typing.Any) -&gt; None</code>","text":"<p>Write the raster to a file.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def to_file(self, path: FilePath, **kwargs: typing.Any) -&gt; None:\n    \"\"\"Write the raster to a file.\"\"\"\n    from rasterra._io import write_raster\n\n    write_raster(self, path, **kwargs)\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.to_numpy","title":"<code>to_numpy() -&gt; RasterData</code>","text":"<p>Convert the raster to a NumPy array.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def to_numpy(self) -&gt; RasterData:\n    \"\"\"Convert the raster to a NumPy array.\"\"\"\n    return self._ndarray.copy()\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.unset_no_data_value","title":"<code>unset_no_data_value() -&gt; RasterArray</code>","text":"<p>Unset value representing no data.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def unset_no_data_value(self) -&gt; \"RasterArray\":\n    \"\"\"Unset value representing no data.\"\"\"\n    return RasterArray(\n        self._ndarray.copy(), self._transform, self._crs, NO_DATA_UNSET\n    )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.x_coordinates","title":"<code>x_coordinates(*, center: bool = False) -&gt; npt.NDArray[np.floating[typing.Any]]</code>","text":"<p>x coordinates of the raster.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def x_coordinates(\n    self, *, center: bool = False\n) -&gt; npt.NDArray[np.floating[typing.Any]]:\n    \"\"\"x coordinates of the raster.\"\"\"\n    if center:\n        return np.linspace(\n            self.x_min + self.x_resolution / 2,\n            self.x_max - self.x_resolution / 2,\n            self.width,\n        )\n    else:\n        return np.linspace(\n            self.x_min,\n            self.x_max - self.x_resolution,\n            self.width,\n        )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.RasterArray.y_coordinates","title":"<code>y_coordinates(*, center: bool = False) -&gt; npt.NDArray[np.floating[typing.Any]]</code>","text":"<p>y coordinates of the raster.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def y_coordinates(\n    self, *, center: bool = False\n) -&gt; npt.NDArray[np.floating[typing.Any]]:\n    \"\"\"y coordinates of the raster.\"\"\"\n    if center:\n        return np.linspace(\n            self.y_min - self.y_resolution / 2,\n            self.y_max + self.y_resolution / 2,\n            self.height,\n        )\n    else:\n        return np.linspace(\n            self.y_min - self.y_resolution,\n            self.y_max,\n            self.height,\n        )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.get_raster_metadata","title":"<code>get_raster_metadata(path: FilePath) -&gt; dict[str, Any]</code>","text":"<p>Get metadata from a raster file without loading the data.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>Dictionary containing raster metadata including: - driver: The raster driver (e.g., 'GTiff') - height: Number of rows - width: Number of columns - count: Number of bands - dtype: Data type - crs: Coordinate reference system - transform: Affine transformation matrix - nodata: No data value - bounds: Spatial bounds (left, bottom, right, top) - res: Pixel resolution (x_res, y_res) - tags: Dataset tags/metadata - units: Units of measurement (if specified) - descriptions: Band descriptions - scales: Band scale factors - offsets: Band offset values - colormap: Color interpretation for each band - block_shapes: Block shapes for each band - compression: Compression type if any - interleaving: Pixel/band interleaving type - is_tiled: Whether the raster is tiled - name: Dataset name/identifier - profile: Full raster profile with all metadata - statistics: Per-band statistics (min, max, mean, std) - nodatavals: No data values for each band - indexes: Band indexes - overviews: Number of overview levels for each band - mask_flags: Mask flags for each band - meta: Additional metadata dictionary - rpcs: Rational polynomial coefficients if available - gcps: Ground control points if available - subdatasets: List of subdatasets if present - photometric: Color interpretation type - is_masked: Whether the dataset has a mask - band_descriptions: Tuple of band names/descriptions - dtypes: Data types for each band - sharing: Whether dataset arrays share memory - dataset_mask: Dataset-wide mask flags - transform_method: Method used for coordinate transforms - width_height: (width, height) tuple</p> Source code in <code>src/rasterra/_io.py</code> <pre><code>def get_raster_metadata(path: FilePath) -&gt; dict[str, Any]:\n    \"\"\"Get metadata from a raster file without loading the data.\n\n    Returns:\n        dict: Dictionary containing raster metadata including:\n            - driver: The raster driver (e.g., 'GTiff')\n            - height: Number of rows\n            - width: Number of columns\n            - count: Number of bands\n            - dtype: Data type\n            - crs: Coordinate reference system\n            - transform: Affine transformation matrix\n            - nodata: No data value\n            - bounds: Spatial bounds (left, bottom, right, top)\n            - res: Pixel resolution (x_res, y_res)\n            - tags: Dataset tags/metadata\n            - units: Units of measurement (if specified)\n            - descriptions: Band descriptions\n            - scales: Band scale factors\n            - offsets: Band offset values\n            - colormap: Color interpretation for each band\n            - block_shapes: Block shapes for each band\n            - compression: Compression type if any\n            - interleaving: Pixel/band interleaving type\n            - is_tiled: Whether the raster is tiled\n            - name: Dataset name/identifier\n            - profile: Full raster profile with all metadata\n            - statistics: Per-band statistics (min, max, mean, std)\n            - nodatavals: No data values for each band\n            - indexes: Band indexes\n            - overviews: Number of overview levels for each band\n            - mask_flags: Mask flags for each band\n            - meta: Additional metadata dictionary\n            - rpcs: Rational polynomial coefficients if available\n            - gcps: Ground control points if available\n            - subdatasets: List of subdatasets if present\n            - photometric: Color interpretation type\n            - is_masked: Whether the dataset has a mask\n            - band_descriptions: Tuple of band names/descriptions\n            - dtypes: Data types for each band\n            - sharing: Whether dataset arrays share memory\n            - dataset_mask: Dataset-wide mask flags\n            - transform_method: Method used for coordinate transforms\n            - width_height: (width, height) tuple\n    \"\"\"\n    with rasterio.open(path) as f:\n        return {\n            \"driver\": f.driver,\n            \"height\": f.height,\n            \"width\": f.width,\n            \"count\": f.count,\n            \"crs\": f.crs,\n            \"dtypes\": f.dtypes,\n            \"transform\": f.transform,\n            \"nodata\": f.nodata,\n            \"bounds\": f.bounds,\n            \"res\": f.res,\n            \"tags\": f.tags(),\n            \"units\": f.units,\n            \"descriptions\": f.descriptions,\n            \"scales\": f.scales,\n            \"offsets\": f.offsets,\n            \"block_shapes\": f.block_shapes,\n            \"compression\": f.compression.value if f.compression else None,\n            \"interleaving\": f.interleaving.value if f.interleaving else None,\n            \"is_tiled\": f.is_tiled,\n            \"name\": f.name,\n            \"statistics\": f.stats(),\n            \"nodatavals\": f.nodatavals,\n            \"indexes\": f.indexes,\n            \"overviews\": [f.overviews(i) for i in range(1, f.count + 1)]\n            if f.count &gt; 0\n            else None,\n            \"mask_flags\": f._mask_flags,  # noqa: SLF001\n            \"rpcs\": f.rpcs,\n            \"gcps\": f.gcps,\n            \"subdatasets\": f.subdatasets,\n            \"photometric\": f.photometric,\n            \"band_descriptions\": f.descriptions,\n        }\n</code></pre>"},{"location":"reference/rasterra/#rasterra.load_mf_raster","title":"<code>load_mf_raster(paths: Sequence[FilePath], band: int | None = None) -&gt; RasterArray</code>","text":"<p>Load multiple files into a single raster.</p>"},{"location":"reference/rasterra/#rasterra.load_mf_raster--parameters","title":"Parameters","text":"<p>paths : Sequence[FilePath]     Paths to the raster files to merge band : int | None, optional     Band number to load (1-based indexing). If None, verifies single-band raster.</p> Source code in <code>src/rasterra/_io.py</code> <pre><code>def load_mf_raster(paths: Sequence[FilePath], band: int | None = None) -&gt; RasterArray:\n    \"\"\"Load multiple files into a single raster.\n\n    Parameters\n    ----------\n    paths : Sequence[FilePath]\n        Paths to the raster files to merge\n    band : int | None, optional\n        Band number to load (1-based indexing). If None, verifies single-band raster.\n    \"\"\"\n    # Verify all files have compatible metadata\n    with rasterio.open(paths[0]) as f:\n        ref_crs = f.crs\n        ref_dtype = f.dtypes[0]\n        ref_nodata = f.nodata\n        ref_count = f.count\n\n        if band is None and ref_count &gt; 1:\n            msg = (\n                f\"First raster has {ref_count} bands. Specify which band to \"\n                \"load using the 'band' argument\"\n            )\n            raise ValueError(msg)\n\n    # Check all other files match\n    for path in paths[1:]:\n        with rasterio.open(path) as f:\n            p = str(path)\n            if f.crs != ref_crs:\n                msg = f\"CRS mismatch: {p} has CRS {f.crs}, expected {ref_crs}\"\n                raise ValueError(msg)\n            if f.dtypes[0] != ref_dtype:\n                msg = (\n                    f\"Dtype mismatch: {p} has dtype {f.dtypes[0]}, expected {ref_dtype}\"\n                )\n                raise ValueError(msg)\n            if f.nodata != ref_nodata:\n                msg = (\n                    f\"NoData mismatch: {p} has nodata {f.nodata}, expected {ref_nodata}\"\n                )\n                raise ValueError(msg)\n            if f.count != ref_count:\n                msg = (\n                    f\"Band count mismatch: {p} has {f.count} bands, \"\n                    f\"expected {ref_count}\"\n                )\n                raise ValueError(msg)\n\n    band_to_read = 1 if band is None else band\n    merged, transform = merge(paths, indexes=[band_to_read])\n\n    return RasterArray(\n        merged[0],\n        transform=transform,\n        crs=ref_crs,\n        no_data_value=ref_nodata,\n    )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.load_raster","title":"<code>load_raster(path: FilePath, bounds: Bounds | None = None, band: int | None = None) -&gt; RasterArray</code>","text":"<p>Load a raster from a file.</p>"},{"location":"reference/rasterra/#rasterra.load_raster--parameters","title":"Parameters","text":"<p>path : FilePath     Path to the raster file bounds : Bounds | None, optional     Bounds to load, by default None band : int | None, optional     Band number to load (1-based indexing). If None, verifies single-band raster.</p> Source code in <code>src/rasterra/_io.py</code> <pre><code>def load_raster(\n    path: FilePath,\n    bounds: Bounds | None = None,\n    band: int | None = None,\n) -&gt; RasterArray:\n    \"\"\"Load a raster from a file.\n\n    Parameters\n    ----------\n    path : FilePath\n        Path to the raster file\n    bounds : Bounds | None, optional\n        Bounds to load, by default None\n    band : int | None, optional\n        Band number to load (1-based indexing). If None, verifies single-band raster.\n    \"\"\"\n    with rasterio.open(path) as f:\n        if band is None and f.count &gt; 1:\n            msg = (\n                f\"Raster has {f.count} bands. Specify which band to \"\n                \"load using the 'band' argument\"\n            )\n            raise ValueError(msg)\n\n        band_to_read = 1 if band is None else band\n\n        if bounds is not None:\n            if isinstance(bounds, Polygon):\n                bounds = bounds.bounds\n            window = from_bounds(*bounds, transform=f.transform)\n            data = f.read(band_to_read, window=window, boundless=True)\n            transform = f.window_transform(window)\n        else:\n            data = f.read(band_to_read)\n            transform = f.transform\n\n        return RasterArray(\n            data,\n            transform=transform,\n            crs=f.crs,\n            no_data_value=f.nodata,\n        )\n</code></pre>"},{"location":"reference/rasterra/#rasterra.merge","title":"<code>merge(rasters: list[RasterArray], method: Literal['first', 'last', 'min', 'max', 'sum', 'count'] = 'first') -&gt; RasterArray</code>","text":"<p>Merge a list of rasters into a single raster.</p> Source code in <code>src/rasterra/_merge.py</code> <pre><code>def merge(\n    rasters: list[RasterArray],\n    method: Literal[\"first\", \"last\", \"min\", \"max\", \"sum\", \"count\"] = \"first\",\n) -&gt; RasterArray:\n    \"\"\"Merge a list of rasters into a single raster.\"\"\"\n    validate_property(rasters, \"crs\")\n    crs = rasters[0].crs\n    validate_property(rasters, \"dtype\")\n    dtype = rasters[0].dtype\n    no_data_isnan = bool(\n        np.issubdtype(dtype, np.floating) and np.isnan(rasters[0].no_data_value)\n    )\n    validate_property(rasters, \"no_data_value\", is_nan=no_data_isnan)\n    no_data_value = rasters[0].no_data_value\n    validate_property(rasters, \"resolution\")\n    x_res, y_res = rasters[0].resolution\n    y_res = -y_res  # rasterio uses negative y resolution\n\n    merge_method = rio_merge.MERGE_METHODS[method]\n\n    left, right, bottom, top = zip(*[raster.bounds for raster in rasters], strict=False)\n    dst_w, dst_s, dst_e, dst_n = min(left), min(bottom), max(right), max(top)\n\n    output_width = int(round((dst_e - dst_w) / x_res))\n    output_height = int(round((dst_n - dst_s) / y_res))\n\n    dest = no_data_value * np.ones((output_height, output_width), dtype=dtype)\n    for raster in rasters:\n        # Find the row and column offset of the input raster\n        row_off = int(round((dst_n - raster.y_max) / y_res))\n        col_off = int(round((raster.x_min - dst_w) / x_res))\n        window = (\n            slice(row_off, row_off + raster.height),\n            slice(col_off, col_off + raster.width),\n        )\n        dest_region = dest[window]\n        if np.isnan(no_data_value):\n            dest_mask = np.isnan(dest_region)\n        elif np.issubdtype(dtype, np.floating):\n            dest_mask = np.isclose(dest_region, no_data_value)\n        else:\n            dest_mask = dest_region == no_data_value\n\n        source_mask = raster.no_data_mask\n        merge_method(dest_region, raster.to_numpy(), dest_mask, source_mask)\n\n    dest_transform = affine.Affine(\n        a=x_res,\n        b=0,\n        c=dst_w,\n        d=0,\n        e=-y_res,\n        f=dst_n,\n    )\n    return RasterArray(\n        dest,\n        transform=dest_transform,\n        crs=crs,\n        no_data_value=no_data_value,\n    )\n</code></pre>"},{"location":"reference/rasterra/_array/","title":"_array","text":""},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray","title":"<code>RasterArray</code>","text":"<p>               Bases: <code>NDArrayOperatorsMixin</code></p> Source code in <code>src/rasterra/_array.py</code> <pre><code>class RasterArray(np.lib.mixins.NDArrayOperatorsMixin):\n    def __init__(\n        self,\n        data: RasterData,\n        transform: Affine = _IDENTITY_TRANSFORM,\n        crs: RawCRS | None = None,\n        no_data_value: SupportedDtypes | None = NO_DATA_UNSET,\n    ):\n        \"\"\"\n        Initialize a RasterArray.\n\n        Parameters\n        ----------\n        data\n            2D NumPy array representing raster data.\n        transform\n            Affine transform to georeference the raster.\n        crs\n            Coordinate reference system.\n        no_data_value\n            Value representing no data.\n\n        \"\"\"\n        self._ndarray = data\n        self._transform = transform\n        if crs is not None and not isinstance(crs, CRS):\n            crs = CRS.from_user_input(crs)\n        self._crs: CRS | None = crs\n        self._no_data_value = no_data_value\n\n    # ----------------------------------------------------------------\n    # Array data\n\n    @property\n    def flags(self) -&gt; flagsobj:\n        \"\"\"Flags of the raster.\"\"\"\n        return self._ndarray.flags\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"Shape of the raster.\"\"\"\n        return self._ndarray.shape\n\n    @property\n    def strides(self) -&gt; tuple[int, ...]:\n        \"\"\"Strides of the raster.\"\"\"\n        return self._ndarray.strides\n\n    @property\n    def ndim(self) -&gt; int:\n        \"\"\"Number of dimensions of the raster.\"\"\"\n        return 2\n\n    @property\n    def data(self) -&gt; memoryview:\n        \"\"\"Python buffer object pooint to the start of the raster's data.\"\"\"\n        return self._ndarray.data\n\n    @property\n    def size(self) -&gt; int:\n        \"\"\"Number of elements in the raster.\"\"\"\n        return self._ndarray.size\n\n    @property\n    def itemsize(self) -&gt; int:\n        \"\"\"Size of each element in the raster.\"\"\"\n        return self._ndarray.itemsize\n\n    @property\n    def nbytes(self) -&gt; int:\n        \"\"\"Number of bytes in the raster.\"\"\"\n        return self._ndarray.nbytes\n\n    @property\n    def base(self) -&gt; RasterData | None:\n        \"\"\"Base object of the raster.\"\"\"\n        return self._ndarray.base\n\n    @property\n    def dtype(self) -&gt; np.dtype[DataDtypes]:\n        \"\"\"Data type of the raster.\"\"\"\n        return self._ndarray.dtype\n\n    @property\n    def T(self) -&gt; typing.NoReturn:  # noqa: N802\n        \"\"\"Transpose of the raster.\"\"\"\n        msg = \"Transpose of a raster is not defined.\"\n        raise TypeError(msg)\n\n    @property\n    def real(self) -&gt; typing.NoReturn:\n        \"\"\"Real part of the raster.\"\"\"\n        msg = \"Complex raster data is not supported.\"\n        raise NotImplementedError(msg)\n\n    @property\n    def imag(self) -&gt; typing.NoReturn:\n        \"\"\"Imaginary part of the raster.\"\"\"\n        msg = \"Complex raster data is not supported.\"\n        raise NotImplementedError(msg)\n\n    @property\n    def flat(self) -&gt; np.flatiter:  # type: ignore[type-arg]\n        \"\"\"Flat iterator of the raster.\"\"\"\n        return self._ndarray.flat\n\n    @property\n    def ctypes(self) -&gt; typing.NoReturn:\n        \"\"\"ctypes object of the raster.\"\"\"\n        msg = \"ctypes object of a raster is not defined.\"\n        raise TypeError(msg)\n\n    def __getitem__(self, item: int | slice | tuple[int, int] | tuple[slice, slice]):  # type: ignore[no-untyped-def]\n        def _process_item(_item: int | slice) -&gt; int | slice:\n            if isinstance(_item, int):\n                return _item\n            elif isinstance(_item, slice):\n                if _item.step is not None:\n                    msg = \"Slicing with a step is not supported.\"\n                    raise ValueError(msg)\n                return _item.start or 0\n            else:\n                msg = \"Invalid index type\"\n                raise TypeError(msg)\n\n        new_data = self._ndarray[item]\n        if not isinstance(new_data, np.ndarray):\n            return new_data\n\n        if isinstance(item, tuple):\n            if len(item) != 2:  # noqa: PLR2004\n                msg = \"Invalid number of indices\"\n                raise ValueError(msg)\n            y_item, x_item = item\n\n            yi = _process_item(y_item)\n            xi = _process_item(x_item)\n        else:\n            yi = _process_item(item)\n            xi = 0\n\n        new_transform = Affine(\n            self._transform.a,\n            self._transform.b,\n            self._transform.c + xi * self._transform.a,\n            self._transform.d,\n            self._transform.e,\n            self._transform.f + yi * self._transform.e,\n        )\n\n        return RasterArray(new_data, new_transform, self._crs, self._no_data_value)\n\n    # ----------------------------------------------------------------\n    # NumPy array interface\n\n    def astype(self, dtype: type[DataDtypes]) -&gt; \"RasterArray\":\n        \"\"\"Cast the raster to a new data type.\"\"\"\n        return RasterArray(\n            self._ndarray.astype(dtype), self._transform, self._crs, self._no_data_value\n        )\n\n    def to_numpy(self) -&gt; RasterData:\n        \"\"\"Convert the raster to a NumPy array.\"\"\"\n        return self._ndarray.copy()\n\n    def __array__(self, dtype: type[DataDtypes] | None = None) -&gt; RasterData:\n        return np.asarray(self._ndarray, dtype=dtype)\n\n    def __array_ufunc__(  # noqa: C901\n        self,\n        ufunc: np.ufunc,\n        method: NumpyUFuncMethod,\n        *inputs: typing.Union[RasterData, SupportedDtypes, \"RasterArray\"],\n        **kwargs: typing.Any,\n    ) -&gt; typing.Union[tuple[\"RasterArray\", ...], \"RasterArray\"]:\n        out = kwargs.get(\"out\", ())\n        for x in inputs + out:\n            # Only support operations with instances of _HANDLED_TYPES.\n            # Use RasterArray instead of type(self) for isinstance to\n            # allow subclasses that don't override __array_ufunc__ to\n            # handle RasterArray objects.\n            handled_types = (np.ndarray, numbers.Number, RasterArray)\n            if not isinstance(x, handled_types):\n                return NotImplemented  # type: ignore[no-any-return]\n            if isinstance(x, RasterArray):\n                if x._crs != self._crs:  # noqa: SLF001\n                    msg = \"Coordinate reference systems do not match.\"\n                    raise ValueError(msg)\n                if not self._no_data_equal(x._no_data_value):  # noqa: SLF001\n                    msg = \"No data values do not match.\"\n                    raise ValueError(msg)\n                if x._transform != self._transform:  # noqa: SLF001\n                    msg = \"Affine transforms do not match.\"\n                    raise ValueError(msg)\n\n        # Propagate the no_data_value to the output array.\n        no_data_mask = self.no_data_mask\n        for x in inputs:\n            if isinstance(x, RasterArray):\n                no_data_mask |= x.no_data_mask\n\n        # Defer to the implementation of the ufunc on unwrapped values.\n        inputs = tuple(x._ndarray if isinstance(x, RasterArray) else x for x in inputs)  # noqa: SLF001\n        if out:\n            kwargs[\"out\"] = tuple(\n                x._ndarray if isinstance(x, RasterArray) else x  # noqa: SLF001\n                for x in out\n            )\n        result = getattr(ufunc, method)(*inputs, **kwargs)\n        result[no_data_mask] = self._no_data_value\n\n        if type(result) is tuple:\n            # multiple return values\n            return tuple(\n                type(self)(x, self._transform, self._crs, self._no_data_value)\n                for x in result\n            )\n        else:\n            # one return value\n            return type(self)(result, self._transform, self._crs, self._no_data_value)\n\n    # ----------------------------------------------------------------\n    # Specialized array methods\n\n    def all(self) -&gt; bool:\n        \"\"\"Return True if all elements evaluate to True.\"\"\"\n        return self._ndarray.all()  # type: ignore[return-value]\n\n    def any(self) -&gt; bool:\n        \"\"\"Return True if any element evaluates to True.\"\"\"\n        return self._ndarray.any()  # type: ignore[return-value]\n\n    # ----------------------------------------------------------------\n    # Raster data\n\n    @property\n    def transform(self) -&gt; Affine:\n        \"\"\"Affine transform to georeference the raster.\"\"\"\n        return self._transform\n\n    @property\n    def x_min(self) -&gt; float:\n        \"\"\"Minimum x coordinate.\"\"\"\n        return self.transform.c  # type: ignore[no-any-return]\n\n    @property\n    def x_max(self) -&gt; float:\n        \"\"\"Maximum x coordinate.\"\"\"\n        return self.x_min + self.x_resolution * self.width\n\n    @property\n    def y_min(self) -&gt; float:\n        \"\"\"Minimum y coordinate.\"\"\"\n        return self.y_max + self.y_resolution * self.height\n\n    @property\n    def y_max(self) -&gt; float:\n        \"\"\"Maximum y coordinate.\"\"\"\n        return self.transform.f  # type: ignore[no-any-return]\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Width of the raster.\"\"\"\n        return self._ndarray.shape[1]\n\n    @property\n    def height(self) -&gt; int:\n        \"\"\"Height of the raster.\"\"\"\n        return self._ndarray.shape[0]\n\n    @property\n    def x_resolution(self) -&gt; float:\n        \"\"\"Resolution in x direction.\"\"\"\n        return self.transform.a  # type: ignore[no-any-return]\n\n    @property\n    def y_resolution(self) -&gt; float:\n        \"\"\"Resolution in y direction.\"\"\"\n        return self.transform.e  # type: ignore[no-any-return]\n\n    @property\n    def resolution(self) -&gt; tuple[float, float]:\n        \"\"\"Resolution in x and y directions.\"\"\"\n        return self.x_resolution, self.y_resolution\n\n    def x_coordinates(\n        self, *, center: bool = False\n    ) -&gt; npt.NDArray[np.floating[typing.Any]]:\n        \"\"\"x coordinates of the raster.\"\"\"\n        if center:\n            return np.linspace(\n                self.x_min + self.x_resolution / 2,\n                self.x_max - self.x_resolution / 2,\n                self.width,\n            )\n        else:\n            return np.linspace(\n                self.x_min,\n                self.x_max - self.x_resolution,\n                self.width,\n            )\n\n    def y_coordinates(\n        self, *, center: bool = False\n    ) -&gt; npt.NDArray[np.floating[typing.Any]]:\n        \"\"\"y coordinates of the raster.\"\"\"\n        if center:\n            return np.linspace(\n                self.y_min - self.y_resolution / 2,\n                self.y_max + self.y_resolution / 2,\n                self.height,\n            )\n        else:\n            return np.linspace(\n                self.y_min - self.y_resolution,\n                self.y_max,\n                self.height,\n            )\n\n    @property\n    def bounds(self) -&gt; tuple[float, float, float, float]:\n        \"\"\"Bounding box of the raster.\"\"\"\n        return self.x_min, self.x_max, self.y_min, self.y_max\n\n    @property\n    def crs(self) -&gt; str | None:\n        \"\"\"Coordinate reference system.\"\"\"\n        if isinstance(self._crs, CRS):\n            return self._crs.to_string()  # type: ignore[no-any-return]\n        else:\n            return self._crs\n\n    def set_crs(self, new_crs: RawCRS) -&gt; \"RasterArray\":\n        if self._crs is not None:\n            msg = (\n                \"Coordinate reference system is already set. Use to_crs() to reproject \"\n                \"to a new coordinate reference system.\"\n            )\n            raise ValueError(msg)\n        return RasterArray(\n            self._ndarray.copy(), self._transform, new_crs, self._no_data_value\n        )\n\n    def to_crs(self, new_crs: str, resampling: str = \"nearest\") -&gt; \"RasterArray\":\n        \"\"\"Reproject the raster to a new coordinate reference system.\"\"\"\n        if self._crs is None:\n            msg = \"Coordinate reference system is not set.\"\n            raise ValueError(msg)\n        return self.reproject(\n            dst_crs=new_crs,\n            resampling=resampling,\n        )\n\n    @property\n    def no_data_value(self) -&gt; SupportedDtypes:\n        \"\"\"Value representing no data.\"\"\"\n        if self._no_data_value is NO_DATA_UNSET:\n            msg = \"No data value is not set.\"\n            raise ValueError(msg)\n        return self._no_data_value\n\n    def set_no_data_value(self, new_no_data_value: SupportedDtypes) -&gt; \"RasterArray\":\n        new_data = self._ndarray.copy()\n        if self._no_data_value is not NO_DATA_UNSET:\n            new_data[self.no_data_mask] = new_no_data_value\n        return RasterArray(new_data, self._transform, self._crs, new_no_data_value)\n\n    def _no_data_equal(self, other_no_data_value: SupportedDtypes | None) -&gt; bool:\n        if self._no_data_value is NO_DATA_UNSET:\n            return other_no_data_value is NO_DATA_UNSET\n        elif other_no_data_value is NO_DATA_UNSET:\n            return False\n        elif np.isnan(self._no_data_value):\n            return np.isnan(other_no_data_value)  # type: ignore[no-any-return]\n        elif np.isinf(self._no_data_value):\n            other_inf = np.isinf(other_no_data_value)\n            sign_match = np.sign(self._no_data_value) == np.sign(other_no_data_value)\n            return other_inf and sign_match  # type: ignore[no-any-return]\n        else:\n            return self._no_data_value == other_no_data_value\n\n    def unset_no_data_value(self) -&gt; \"RasterArray\":\n        \"\"\"Unset value representing no data.\"\"\"\n        return RasterArray(\n            self._ndarray.copy(), self._transform, self._crs, NO_DATA_UNSET\n        )\n\n    @property\n    def no_data_mask(self) -&gt; RasterMask:\n        \"\"\"Mask representing no data.\"\"\"\n        if self._no_data_value is NO_DATA_UNSET:\n            return np.zeros_like(self._ndarray, dtype=bool)\n        elif np.isnan(self._no_data_value):\n            return np.isnan(self._ndarray)\n        elif np.isinf(self._no_data_value):\n            return np.isinf(self._ndarray)\n        else:\n            return np.equal(self._ndarray, self._no_data_value)\n\n    def resample(self, scale: float, resampling: str = \"nearest\") -&gt; \"RasterArray\":\n        \"\"\"Resample the raster.\"\"\"\n        dest_width = int(self.width * scale)\n        dest_height = int(self.height * scale)\n        destination = np.empty((dest_height, dest_width), dtype=self._ndarray.dtype)\n        return self.reproject(\n            destination=destination,\n            dst_crs=self._crs,\n            resampling=resampling,\n        )\n\n    def resample_to(\n        self, target: \"RasterArray\", resampling: str = \"nearest\"\n    ) -&gt; \"RasterArray\":\n        \"\"\"Resample the raster to match the resolution of another raster.\"\"\"\n        destination = np.empty_like(target._ndarray, dtype=self._ndarray.dtype)  # noqa: SLF001\n        return self.reproject(\n            destination=destination,\n            dst_transform=target.transform,\n            dst_crs=target._crs,  # noqa: SLF001\n            resampling=resampling,\n        )\n\n    def reproject(\n        self,\n        destination: RasterData | None = None,\n        dst_transform: Affine | None = None,\n        dst_resolution: float | tuple[float, float] | None = None,\n        dst_crs: RawCRS | None = None,\n        resampling: str = \"nearest\",\n    ) -&gt; \"RasterArray\":\n        \"\"\"Reproject the raster to match the resolution of another raster.\"\"\"\n        resampling = _RESAMPLING_MAP[resampling]\n\n        dst_crs = self._crs if dst_crs is None else CRS.from_user_input(dst_crs)\n        new_data, transform = reproject(\n            source=self._ndarray,\n            src_transform=self._transform,\n            src_crs=self._crs,\n            src_nodata=self._no_data_value,\n            destination=destination,\n            dst_transform=dst_transform,\n            dst_resolution=dst_resolution,\n            dst_crs=dst_crs,\n            resampling=resampling,\n        )\n        if len(new_data.shape) == 3:  # noqa: PLR2004\n            # Some operations assume and prepend a channel dimension\n            new_data = new_data[0]\n        return RasterArray(\n            new_data,\n            transform,\n            dst_crs,\n            self.no_data_value,\n        )\n\n    def _coerce_to_shapely(\n        self, shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries\n    ) -&gt; Polygon | MultiPolygon:\n        if isinstance(shape, (gpd.GeoDataFrame, gpd.GeoSeries)):\n            if shape.crs != self._crs:\n                msg = \"Coordinate reference systems do not match.\"\n                raise ValueError(msg)\n            return shape.geometry.unary_union\n        return shape\n\n    def clip(\n        self, shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries\n    ) -&gt; \"RasterArray\":\n        \"\"\"Clip the raster to a shape.\"\"\"\n        shape = self._coerce_to_shapely(shape)\n        _, transform, window = raster_geometry_mask(\n            data_transform=self.transform,\n            data_width=self._ndarray.shape[1],\n            data_height=self._ndarray.shape[0],\n            shapes=[shape],\n            crop=True,\n        )\n\n        x_start, x_end = window.col_off, window.col_off + window.width\n        y_start, y_end = window.row_off, window.row_off + window.height\n        new_data = self._ndarray[y_start:y_end, x_start:x_end].copy()\n        return RasterArray(\n            new_data, transform, self._crs, no_data_value=self.no_data_value\n        )\n\n    def mask(\n        self,\n        shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries,\n        *,\n        fill_value: SupportedDtypes | None = None,\n        all_touched: bool = False,\n        invert: bool = False,\n    ) -&gt; \"RasterArray\":\n        \"\"\"Mask the raster with a shape.\"\"\"\n        shape = self._coerce_to_shapely(shape)\n        if fill_value is None and self._no_data_value is NO_DATA_UNSET:\n            msg = \"No fill value is set.\"\n            raise ValueError(msg)\n\n        if fill_value is None:\n            fill_value = self.no_data_value\n\n        shape_mask, *_ = raster_geometry_mask(\n            data_transform=self.transform,\n            data_width=self._ndarray.shape[1],\n            data_height=self._ndarray.shape[0],\n            shapes=[shape],\n            all_touched=all_touched,\n            invert=invert,\n        )\n        new_data = self._ndarray.copy()\n        new_data[shape_mask] = fill_value\n\n        return RasterArray(\n            new_data, self.transform, self._crs, no_data_value=self.no_data_value\n        )\n\n    def select(\n        self,\n        x_coordinates: npt.NDArray[np.float64],\n        y_coordinates: npt.NDArray[np.float64],\n        method: str = \"nearest\",\n    ) -&gt; npt.NDArray[DataDtypes]:\n        \"\"\"Select values at specific coordinates.\"\"\"\n        if x_coordinates.size != y_coordinates.size:\n            msg = \"x and y coordinates must have the same size.\"\n            raise ValueError(msg)\n\n        if method == \"nearest\":\n            x_indices = np.clip(\n                np.searchsorted(self.x_coordinates(), x_coordinates),\n                0,\n                self.width - 1,\n            )\n            y_indices = np.searchsorted(\n                self.y_coordinates(), y_coordinates, side=\"right\"\n            )\n            # Flip y indices to match raster coordinatesok\n            y_indices = np.clip(\n                self.height - y_indices,\n                0,\n                self.height - 1,\n            )\n\n            return self._ndarray[y_indices, x_indices].copy()\n        else:\n            msg = \"Only 'nearest' method is supported.\"\n            raise NotImplementedError(msg)\n\n    def __repr__(self) -&gt; str:\n        out = \"RasterArray\\n\"\n        out += \"===========\\n\"\n        out += f\"dimensions    : {self.width}, {self.height} (x, y)\\n\"\n        out += f\"resolution    : {self.transform.a}, {self.transform.e} (x, y)\\n\"\n        bounds = \", \".join(\n            str(s) for s in [self.x_min, self.x_max, self.y_min, self.y_max]\n        )\n        out += f\"extent        : {bounds} (xmin, xmax, ymin, ymax)\\n\"\n        out += f\"crs           : {self.crs}\\n\"\n        out += f\"no_data_value : {self._no_data_value}\\n\"\n        out += f\"size          : {self.nbytes / 1024**2:.2f} MB\\n\"\n        out += f\"dtype         : {self._ndarray.dtype}\\n\"\n        return out\n\n    def to_file(self, path: FilePath, **kwargs: typing.Any) -&gt; None:\n        \"\"\"Write the raster to a file.\"\"\"\n        from rasterra._io import write_raster\n\n        write_raster(self, path, **kwargs)\n\n    def to_gdf(self) -&gt; gpd.GeoDataFrame:\n        return to_gdf(self)\n\n    @property\n    def plot(self) -&gt; Plotter:\n        return Plotter(self._ndarray, self.no_data_mask, self.transform)\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.T","title":"<code>T: typing.NoReturn</code>  <code>property</code>","text":"<p>Transpose of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.base","title":"<code>base: RasterData | None</code>  <code>property</code>","text":"<p>Base object of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.bounds","title":"<code>bounds: tuple[float, float, float, float]</code>  <code>property</code>","text":"<p>Bounding box of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.crs","title":"<code>crs: str | None</code>  <code>property</code>","text":"<p>Coordinate reference system.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.ctypes","title":"<code>ctypes: typing.NoReturn</code>  <code>property</code>","text":"<p>ctypes object of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.data","title":"<code>data: memoryview</code>  <code>property</code>","text":"<p>Python buffer object pooint to the start of the raster's data.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.dtype","title":"<code>dtype: np.dtype[DataDtypes]</code>  <code>property</code>","text":"<p>Data type of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.flags","title":"<code>flags: flagsobj</code>  <code>property</code>","text":"<p>Flags of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.flat","title":"<code>flat: np.flatiter</code>  <code>property</code>","text":"<p>Flat iterator of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.height","title":"<code>height: int</code>  <code>property</code>","text":"<p>Height of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.imag","title":"<code>imag: typing.NoReturn</code>  <code>property</code>","text":"<p>Imaginary part of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.itemsize","title":"<code>itemsize: int</code>  <code>property</code>","text":"<p>Size of each element in the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.nbytes","title":"<code>nbytes: int</code>  <code>property</code>","text":"<p>Number of bytes in the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.ndim","title":"<code>ndim: int</code>  <code>property</code>","text":"<p>Number of dimensions of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.no_data_mask","title":"<code>no_data_mask: RasterMask</code>  <code>property</code>","text":"<p>Mask representing no data.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.no_data_value","title":"<code>no_data_value: SupportedDtypes</code>  <code>property</code>","text":"<p>Value representing no data.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.real","title":"<code>real: typing.NoReturn</code>  <code>property</code>","text":"<p>Real part of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.resolution","title":"<code>resolution: tuple[float, float]</code>  <code>property</code>","text":"<p>Resolution in x and y directions.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.shape","title":"<code>shape: tuple[int, ...]</code>  <code>property</code>","text":"<p>Shape of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.size","title":"<code>size: int</code>  <code>property</code>","text":"<p>Number of elements in the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.strides","title":"<code>strides: tuple[int, ...]</code>  <code>property</code>","text":"<p>Strides of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.transform","title":"<code>transform: Affine</code>  <code>property</code>","text":"<p>Affine transform to georeference the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.width","title":"<code>width: int</code>  <code>property</code>","text":"<p>Width of the raster.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.x_max","title":"<code>x_max: float</code>  <code>property</code>","text":"<p>Maximum x coordinate.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.x_min","title":"<code>x_min: float</code>  <code>property</code>","text":"<p>Minimum x coordinate.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.x_resolution","title":"<code>x_resolution: float</code>  <code>property</code>","text":"<p>Resolution in x direction.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.y_max","title":"<code>y_max: float</code>  <code>property</code>","text":"<p>Maximum y coordinate.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.y_min","title":"<code>y_min: float</code>  <code>property</code>","text":"<p>Minimum y coordinate.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.y_resolution","title":"<code>y_resolution: float</code>  <code>property</code>","text":"<p>Resolution in y direction.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.__init__","title":"<code>__init__(data: RasterData, transform: Affine = _IDENTITY_TRANSFORM, crs: RawCRS | None = None, no_data_value: SupportedDtypes | None = NO_DATA_UNSET)</code>","text":"<p>Initialize a RasterArray.</p>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.__init__--parameters","title":"Parameters","text":"<p>data     2D NumPy array representing raster data. transform     Affine transform to georeference the raster. crs     Coordinate reference system. no_data_value     Value representing no data.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def __init__(\n    self,\n    data: RasterData,\n    transform: Affine = _IDENTITY_TRANSFORM,\n    crs: RawCRS | None = None,\n    no_data_value: SupportedDtypes | None = NO_DATA_UNSET,\n):\n    \"\"\"\n    Initialize a RasterArray.\n\n    Parameters\n    ----------\n    data\n        2D NumPy array representing raster data.\n    transform\n        Affine transform to georeference the raster.\n    crs\n        Coordinate reference system.\n    no_data_value\n        Value representing no data.\n\n    \"\"\"\n    self._ndarray = data\n    self._transform = transform\n    if crs is not None and not isinstance(crs, CRS):\n        crs = CRS.from_user_input(crs)\n    self._crs: CRS | None = crs\n    self._no_data_value = no_data_value\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.all","title":"<code>all() -&gt; bool</code>","text":"<p>Return True if all elements evaluate to True.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def all(self) -&gt; bool:\n    \"\"\"Return True if all elements evaluate to True.\"\"\"\n    return self._ndarray.all()  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.any","title":"<code>any() -&gt; bool</code>","text":"<p>Return True if any element evaluates to True.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def any(self) -&gt; bool:\n    \"\"\"Return True if any element evaluates to True.\"\"\"\n    return self._ndarray.any()  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.astype","title":"<code>astype(dtype: type[DataDtypes]) -&gt; RasterArray</code>","text":"<p>Cast the raster to a new data type.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def astype(self, dtype: type[DataDtypes]) -&gt; \"RasterArray\":\n    \"\"\"Cast the raster to a new data type.\"\"\"\n    return RasterArray(\n        self._ndarray.astype(dtype), self._transform, self._crs, self._no_data_value\n    )\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.clip","title":"<code>clip(shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries) -&gt; RasterArray</code>","text":"<p>Clip the raster to a shape.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def clip(\n    self, shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries\n) -&gt; \"RasterArray\":\n    \"\"\"Clip the raster to a shape.\"\"\"\n    shape = self._coerce_to_shapely(shape)\n    _, transform, window = raster_geometry_mask(\n        data_transform=self.transform,\n        data_width=self._ndarray.shape[1],\n        data_height=self._ndarray.shape[0],\n        shapes=[shape],\n        crop=True,\n    )\n\n    x_start, x_end = window.col_off, window.col_off + window.width\n    y_start, y_end = window.row_off, window.row_off + window.height\n    new_data = self._ndarray[y_start:y_end, x_start:x_end].copy()\n    return RasterArray(\n        new_data, transform, self._crs, no_data_value=self.no_data_value\n    )\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.mask","title":"<code>mask(shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries, *, fill_value: SupportedDtypes | None = None, all_touched: bool = False, invert: bool = False) -&gt; RasterArray</code>","text":"<p>Mask the raster with a shape.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def mask(\n    self,\n    shape: Polygon | MultiPolygon | gpd.GeoDataFrame | gpd.GeoSeries,\n    *,\n    fill_value: SupportedDtypes | None = None,\n    all_touched: bool = False,\n    invert: bool = False,\n) -&gt; \"RasterArray\":\n    \"\"\"Mask the raster with a shape.\"\"\"\n    shape = self._coerce_to_shapely(shape)\n    if fill_value is None and self._no_data_value is NO_DATA_UNSET:\n        msg = \"No fill value is set.\"\n        raise ValueError(msg)\n\n    if fill_value is None:\n        fill_value = self.no_data_value\n\n    shape_mask, *_ = raster_geometry_mask(\n        data_transform=self.transform,\n        data_width=self._ndarray.shape[1],\n        data_height=self._ndarray.shape[0],\n        shapes=[shape],\n        all_touched=all_touched,\n        invert=invert,\n    )\n    new_data = self._ndarray.copy()\n    new_data[shape_mask] = fill_value\n\n    return RasterArray(\n        new_data, self.transform, self._crs, no_data_value=self.no_data_value\n    )\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.reproject","title":"<code>reproject(destination: RasterData | None = None, dst_transform: Affine | None = None, dst_resolution: float | tuple[float, float] | None = None, dst_crs: RawCRS | None = None, resampling: str = 'nearest') -&gt; RasterArray</code>","text":"<p>Reproject the raster to match the resolution of another raster.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def reproject(\n    self,\n    destination: RasterData | None = None,\n    dst_transform: Affine | None = None,\n    dst_resolution: float | tuple[float, float] | None = None,\n    dst_crs: RawCRS | None = None,\n    resampling: str = \"nearest\",\n) -&gt; \"RasterArray\":\n    \"\"\"Reproject the raster to match the resolution of another raster.\"\"\"\n    resampling = _RESAMPLING_MAP[resampling]\n\n    dst_crs = self._crs if dst_crs is None else CRS.from_user_input(dst_crs)\n    new_data, transform = reproject(\n        source=self._ndarray,\n        src_transform=self._transform,\n        src_crs=self._crs,\n        src_nodata=self._no_data_value,\n        destination=destination,\n        dst_transform=dst_transform,\n        dst_resolution=dst_resolution,\n        dst_crs=dst_crs,\n        resampling=resampling,\n    )\n    if len(new_data.shape) == 3:  # noqa: PLR2004\n        # Some operations assume and prepend a channel dimension\n        new_data = new_data[0]\n    return RasterArray(\n        new_data,\n        transform,\n        dst_crs,\n        self.no_data_value,\n    )\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.resample","title":"<code>resample(scale: float, resampling: str = 'nearest') -&gt; RasterArray</code>","text":"<p>Resample the raster.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def resample(self, scale: float, resampling: str = \"nearest\") -&gt; \"RasterArray\":\n    \"\"\"Resample the raster.\"\"\"\n    dest_width = int(self.width * scale)\n    dest_height = int(self.height * scale)\n    destination = np.empty((dest_height, dest_width), dtype=self._ndarray.dtype)\n    return self.reproject(\n        destination=destination,\n        dst_crs=self._crs,\n        resampling=resampling,\n    )\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.resample_to","title":"<code>resample_to(target: RasterArray, resampling: str = 'nearest') -&gt; RasterArray</code>","text":"<p>Resample the raster to match the resolution of another raster.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def resample_to(\n    self, target: \"RasterArray\", resampling: str = \"nearest\"\n) -&gt; \"RasterArray\":\n    \"\"\"Resample the raster to match the resolution of another raster.\"\"\"\n    destination = np.empty_like(target._ndarray, dtype=self._ndarray.dtype)  # noqa: SLF001\n    return self.reproject(\n        destination=destination,\n        dst_transform=target.transform,\n        dst_crs=target._crs,  # noqa: SLF001\n        resampling=resampling,\n    )\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.select","title":"<code>select(x_coordinates: npt.NDArray[np.float64], y_coordinates: npt.NDArray[np.float64], method: str = 'nearest') -&gt; npt.NDArray[DataDtypes]</code>","text":"<p>Select values at specific coordinates.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def select(\n    self,\n    x_coordinates: npt.NDArray[np.float64],\n    y_coordinates: npt.NDArray[np.float64],\n    method: str = \"nearest\",\n) -&gt; npt.NDArray[DataDtypes]:\n    \"\"\"Select values at specific coordinates.\"\"\"\n    if x_coordinates.size != y_coordinates.size:\n        msg = \"x and y coordinates must have the same size.\"\n        raise ValueError(msg)\n\n    if method == \"nearest\":\n        x_indices = np.clip(\n            np.searchsorted(self.x_coordinates(), x_coordinates),\n            0,\n            self.width - 1,\n        )\n        y_indices = np.searchsorted(\n            self.y_coordinates(), y_coordinates, side=\"right\"\n        )\n        # Flip y indices to match raster coordinatesok\n        y_indices = np.clip(\n            self.height - y_indices,\n            0,\n            self.height - 1,\n        )\n\n        return self._ndarray[y_indices, x_indices].copy()\n    else:\n        msg = \"Only 'nearest' method is supported.\"\n        raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.to_crs","title":"<code>to_crs(new_crs: str, resampling: str = 'nearest') -&gt; RasterArray</code>","text":"<p>Reproject the raster to a new coordinate reference system.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def to_crs(self, new_crs: str, resampling: str = \"nearest\") -&gt; \"RasterArray\":\n    \"\"\"Reproject the raster to a new coordinate reference system.\"\"\"\n    if self._crs is None:\n        msg = \"Coordinate reference system is not set.\"\n        raise ValueError(msg)\n    return self.reproject(\n        dst_crs=new_crs,\n        resampling=resampling,\n    )\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.to_file","title":"<code>to_file(path: FilePath, **kwargs: typing.Any) -&gt; None</code>","text":"<p>Write the raster to a file.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def to_file(self, path: FilePath, **kwargs: typing.Any) -&gt; None:\n    \"\"\"Write the raster to a file.\"\"\"\n    from rasterra._io import write_raster\n\n    write_raster(self, path, **kwargs)\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.to_numpy","title":"<code>to_numpy() -&gt; RasterData</code>","text":"<p>Convert the raster to a NumPy array.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def to_numpy(self) -&gt; RasterData:\n    \"\"\"Convert the raster to a NumPy array.\"\"\"\n    return self._ndarray.copy()\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.unset_no_data_value","title":"<code>unset_no_data_value() -&gt; RasterArray</code>","text":"<p>Unset value representing no data.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def unset_no_data_value(self) -&gt; \"RasterArray\":\n    \"\"\"Unset value representing no data.\"\"\"\n    return RasterArray(\n        self._ndarray.copy(), self._transform, self._crs, NO_DATA_UNSET\n    )\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.x_coordinates","title":"<code>x_coordinates(*, center: bool = False) -&gt; npt.NDArray[np.floating[typing.Any]]</code>","text":"<p>x coordinates of the raster.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def x_coordinates(\n    self, *, center: bool = False\n) -&gt; npt.NDArray[np.floating[typing.Any]]:\n    \"\"\"x coordinates of the raster.\"\"\"\n    if center:\n        return np.linspace(\n            self.x_min + self.x_resolution / 2,\n            self.x_max - self.x_resolution / 2,\n            self.width,\n        )\n    else:\n        return np.linspace(\n            self.x_min,\n            self.x_max - self.x_resolution,\n            self.width,\n        )\n</code></pre>"},{"location":"reference/rasterra/_array/#rasterra._array.RasterArray.y_coordinates","title":"<code>y_coordinates(*, center: bool = False) -&gt; npt.NDArray[np.floating[typing.Any]]</code>","text":"<p>y coordinates of the raster.</p> Source code in <code>src/rasterra/_array.py</code> <pre><code>def y_coordinates(\n    self, *, center: bool = False\n) -&gt; npt.NDArray[np.floating[typing.Any]]:\n    \"\"\"y coordinates of the raster.\"\"\"\n    if center:\n        return np.linspace(\n            self.y_min - self.y_resolution / 2,\n            self.y_max + self.y_resolution / 2,\n            self.height,\n        )\n    else:\n        return np.linspace(\n            self.y_min - self.y_resolution,\n            self.y_max,\n            self.height,\n        )\n</code></pre>"},{"location":"reference/rasterra/_features/","title":"_features","text":""},{"location":"reference/rasterra/_io/","title":"_io","text":""},{"location":"reference/rasterra/_io/#rasterra._io.get_raster_metadata","title":"<code>get_raster_metadata(path: FilePath) -&gt; dict[str, Any]</code>","text":"<p>Get metadata from a raster file without loading the data.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any]</code> <p>Dictionary containing raster metadata including: - driver: The raster driver (e.g., 'GTiff') - height: Number of rows - width: Number of columns - count: Number of bands - dtype: Data type - crs: Coordinate reference system - transform: Affine transformation matrix - nodata: No data value - bounds: Spatial bounds (left, bottom, right, top) - res: Pixel resolution (x_res, y_res) - tags: Dataset tags/metadata - units: Units of measurement (if specified) - descriptions: Band descriptions - scales: Band scale factors - offsets: Band offset values - colormap: Color interpretation for each band - block_shapes: Block shapes for each band - compression: Compression type if any - interleaving: Pixel/band interleaving type - is_tiled: Whether the raster is tiled - name: Dataset name/identifier - profile: Full raster profile with all metadata - statistics: Per-band statistics (min, max, mean, std) - nodatavals: No data values for each band - indexes: Band indexes - overviews: Number of overview levels for each band - mask_flags: Mask flags for each band - meta: Additional metadata dictionary - rpcs: Rational polynomial coefficients if available - gcps: Ground control points if available - subdatasets: List of subdatasets if present - photometric: Color interpretation type - is_masked: Whether the dataset has a mask - band_descriptions: Tuple of band names/descriptions - dtypes: Data types for each band - sharing: Whether dataset arrays share memory - dataset_mask: Dataset-wide mask flags - transform_method: Method used for coordinate transforms - width_height: (width, height) tuple</p> Source code in <code>src/rasterra/_io.py</code> <pre><code>def get_raster_metadata(path: FilePath) -&gt; dict[str, Any]:\n    \"\"\"Get metadata from a raster file without loading the data.\n\n    Returns:\n        dict: Dictionary containing raster metadata including:\n            - driver: The raster driver (e.g., 'GTiff')\n            - height: Number of rows\n            - width: Number of columns\n            - count: Number of bands\n            - dtype: Data type\n            - crs: Coordinate reference system\n            - transform: Affine transformation matrix\n            - nodata: No data value\n            - bounds: Spatial bounds (left, bottom, right, top)\n            - res: Pixel resolution (x_res, y_res)\n            - tags: Dataset tags/metadata\n            - units: Units of measurement (if specified)\n            - descriptions: Band descriptions\n            - scales: Band scale factors\n            - offsets: Band offset values\n            - colormap: Color interpretation for each band\n            - block_shapes: Block shapes for each band\n            - compression: Compression type if any\n            - interleaving: Pixel/band interleaving type\n            - is_tiled: Whether the raster is tiled\n            - name: Dataset name/identifier\n            - profile: Full raster profile with all metadata\n            - statistics: Per-band statistics (min, max, mean, std)\n            - nodatavals: No data values for each band\n            - indexes: Band indexes\n            - overviews: Number of overview levels for each band\n            - mask_flags: Mask flags for each band\n            - meta: Additional metadata dictionary\n            - rpcs: Rational polynomial coefficients if available\n            - gcps: Ground control points if available\n            - subdatasets: List of subdatasets if present\n            - photometric: Color interpretation type\n            - is_masked: Whether the dataset has a mask\n            - band_descriptions: Tuple of band names/descriptions\n            - dtypes: Data types for each band\n            - sharing: Whether dataset arrays share memory\n            - dataset_mask: Dataset-wide mask flags\n            - transform_method: Method used for coordinate transforms\n            - width_height: (width, height) tuple\n    \"\"\"\n    with rasterio.open(path) as f:\n        return {\n            \"driver\": f.driver,\n            \"height\": f.height,\n            \"width\": f.width,\n            \"count\": f.count,\n            \"crs\": f.crs,\n            \"dtypes\": f.dtypes,\n            \"transform\": f.transform,\n            \"nodata\": f.nodata,\n            \"bounds\": f.bounds,\n            \"res\": f.res,\n            \"tags\": f.tags(),\n            \"units\": f.units,\n            \"descriptions\": f.descriptions,\n            \"scales\": f.scales,\n            \"offsets\": f.offsets,\n            \"block_shapes\": f.block_shapes,\n            \"compression\": f.compression.value if f.compression else None,\n            \"interleaving\": f.interleaving.value if f.interleaving else None,\n            \"is_tiled\": f.is_tiled,\n            \"name\": f.name,\n            \"statistics\": f.stats(),\n            \"nodatavals\": f.nodatavals,\n            \"indexes\": f.indexes,\n            \"overviews\": [f.overviews(i) for i in range(1, f.count + 1)]\n            if f.count &gt; 0\n            else None,\n            \"mask_flags\": f._mask_flags,  # noqa: SLF001\n            \"rpcs\": f.rpcs,\n            \"gcps\": f.gcps,\n            \"subdatasets\": f.subdatasets,\n            \"photometric\": f.photometric,\n            \"band_descriptions\": f.descriptions,\n        }\n</code></pre>"},{"location":"reference/rasterra/_io/#rasterra._io.load_mf_raster","title":"<code>load_mf_raster(paths: Sequence[FilePath], band: int | None = None) -&gt; RasterArray</code>","text":"<p>Load multiple files into a single raster.</p>"},{"location":"reference/rasterra/_io/#rasterra._io.load_mf_raster--parameters","title":"Parameters","text":"<p>paths : Sequence[FilePath]     Paths to the raster files to merge band : int | None, optional     Band number to load (1-based indexing). If None, verifies single-band raster.</p> Source code in <code>src/rasterra/_io.py</code> <pre><code>def load_mf_raster(paths: Sequence[FilePath], band: int | None = None) -&gt; RasterArray:\n    \"\"\"Load multiple files into a single raster.\n\n    Parameters\n    ----------\n    paths : Sequence[FilePath]\n        Paths to the raster files to merge\n    band : int | None, optional\n        Band number to load (1-based indexing). If None, verifies single-band raster.\n    \"\"\"\n    # Verify all files have compatible metadata\n    with rasterio.open(paths[0]) as f:\n        ref_crs = f.crs\n        ref_dtype = f.dtypes[0]\n        ref_nodata = f.nodata\n        ref_count = f.count\n\n        if band is None and ref_count &gt; 1:\n            msg = (\n                f\"First raster has {ref_count} bands. Specify which band to \"\n                \"load using the 'band' argument\"\n            )\n            raise ValueError(msg)\n\n    # Check all other files match\n    for path in paths[1:]:\n        with rasterio.open(path) as f:\n            p = str(path)\n            if f.crs != ref_crs:\n                msg = f\"CRS mismatch: {p} has CRS {f.crs}, expected {ref_crs}\"\n                raise ValueError(msg)\n            if f.dtypes[0] != ref_dtype:\n                msg = (\n                    f\"Dtype mismatch: {p} has dtype {f.dtypes[0]}, expected {ref_dtype}\"\n                )\n                raise ValueError(msg)\n            if f.nodata != ref_nodata:\n                msg = (\n                    f\"NoData mismatch: {p} has nodata {f.nodata}, expected {ref_nodata}\"\n                )\n                raise ValueError(msg)\n            if f.count != ref_count:\n                msg = (\n                    f\"Band count mismatch: {p} has {f.count} bands, \"\n                    f\"expected {ref_count}\"\n                )\n                raise ValueError(msg)\n\n    band_to_read = 1 if band is None else band\n    merged, transform = merge(paths, indexes=[band_to_read])\n\n    return RasterArray(\n        merged[0],\n        transform=transform,\n        crs=ref_crs,\n        no_data_value=ref_nodata,\n    )\n</code></pre>"},{"location":"reference/rasterra/_io/#rasterra._io.load_raster","title":"<code>load_raster(path: FilePath, bounds: Bounds | None = None, band: int | None = None) -&gt; RasterArray</code>","text":"<p>Load a raster from a file.</p>"},{"location":"reference/rasterra/_io/#rasterra._io.load_raster--parameters","title":"Parameters","text":"<p>path : FilePath     Path to the raster file bounds : Bounds | None, optional     Bounds to load, by default None band : int | None, optional     Band number to load (1-based indexing). If None, verifies single-band raster.</p> Source code in <code>src/rasterra/_io.py</code> <pre><code>def load_raster(\n    path: FilePath,\n    bounds: Bounds | None = None,\n    band: int | None = None,\n) -&gt; RasterArray:\n    \"\"\"Load a raster from a file.\n\n    Parameters\n    ----------\n    path : FilePath\n        Path to the raster file\n    bounds : Bounds | None, optional\n        Bounds to load, by default None\n    band : int | None, optional\n        Band number to load (1-based indexing). If None, verifies single-band raster.\n    \"\"\"\n    with rasterio.open(path) as f:\n        if band is None and f.count &gt; 1:\n            msg = (\n                f\"Raster has {f.count} bands. Specify which band to \"\n                \"load using the 'band' argument\"\n            )\n            raise ValueError(msg)\n\n        band_to_read = 1 if band is None else band\n\n        if bounds is not None:\n            if isinstance(bounds, Polygon):\n                bounds = bounds.bounds\n            window = from_bounds(*bounds, transform=f.transform)\n            data = f.read(band_to_read, window=window, boundless=True)\n            transform = f.window_transform(window)\n        else:\n            data = f.read(band_to_read)\n            transform = f.transform\n\n        return RasterArray(\n            data,\n            transform=transform,\n            crs=f.crs,\n            no_data_value=f.nodata,\n        )\n</code></pre>"},{"location":"reference/rasterra/_io/#rasterra._io.write_raster","title":"<code>write_raster(raster: RasterArray, path: FilePath, **kwargs: Any) -&gt; None</code>","text":"<p>Write a raster to a file.</p> Source code in <code>src/rasterra/_io.py</code> <pre><code>def write_raster(\n    raster: RasterArray,\n    path: FilePath,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Write a raster to a file.\"\"\"\n    meta = {\n        \"driver\": \"GTiff\",\n        \"height\": raster.shape[0],\n        \"width\": raster.shape[1],\n        \"count\": 1,\n        \"dtype\": raster.dtype,\n        \"crs\": raster.crs,\n        \"transform\": raster.transform,\n        \"nodata\": raster.no_data_value,\n        **kwargs,\n    }\n\n    with rasterio.open(path, \"w\", **meta) as f:\n        f.write(raster.to_numpy(), 1)\n</code></pre>"},{"location":"reference/rasterra/_merge/","title":"_merge","text":""},{"location":"reference/rasterra/_merge/#rasterra._merge.merge","title":"<code>merge(rasters: list[RasterArray], method: Literal['first', 'last', 'min', 'max', 'sum', 'count'] = 'first') -&gt; RasterArray</code>","text":"<p>Merge a list of rasters into a single raster.</p> Source code in <code>src/rasterra/_merge.py</code> <pre><code>def merge(\n    rasters: list[RasterArray],\n    method: Literal[\"first\", \"last\", \"min\", \"max\", \"sum\", \"count\"] = \"first\",\n) -&gt; RasterArray:\n    \"\"\"Merge a list of rasters into a single raster.\"\"\"\n    validate_property(rasters, \"crs\")\n    crs = rasters[0].crs\n    validate_property(rasters, \"dtype\")\n    dtype = rasters[0].dtype\n    no_data_isnan = bool(\n        np.issubdtype(dtype, np.floating) and np.isnan(rasters[0].no_data_value)\n    )\n    validate_property(rasters, \"no_data_value\", is_nan=no_data_isnan)\n    no_data_value = rasters[0].no_data_value\n    validate_property(rasters, \"resolution\")\n    x_res, y_res = rasters[0].resolution\n    y_res = -y_res  # rasterio uses negative y resolution\n\n    merge_method = rio_merge.MERGE_METHODS[method]\n\n    left, right, bottom, top = zip(*[raster.bounds for raster in rasters], strict=False)\n    dst_w, dst_s, dst_e, dst_n = min(left), min(bottom), max(right), max(top)\n\n    output_width = int(round((dst_e - dst_w) / x_res))\n    output_height = int(round((dst_n - dst_s) / y_res))\n\n    dest = no_data_value * np.ones((output_height, output_width), dtype=dtype)\n    for raster in rasters:\n        # Find the row and column offset of the input raster\n        row_off = int(round((dst_n - raster.y_max) / y_res))\n        col_off = int(round((raster.x_min - dst_w) / x_res))\n        window = (\n            slice(row_off, row_off + raster.height),\n            slice(col_off, col_off + raster.width),\n        )\n        dest_region = dest[window]\n        if np.isnan(no_data_value):\n            dest_mask = np.isnan(dest_region)\n        elif np.issubdtype(dtype, np.floating):\n            dest_mask = np.isclose(dest_region, no_data_value)\n        else:\n            dest_mask = dest_region == no_data_value\n\n        source_mask = raster.no_data_mask\n        merge_method(dest_region, raster.to_numpy(), dest_mask, source_mask)\n\n    dest_transform = affine.Affine(\n        a=x_res,\n        b=0,\n        c=dst_w,\n        d=0,\n        e=-y_res,\n        f=dst_n,\n    )\n    return RasterArray(\n        dest,\n        transform=dest_transform,\n        crs=crs,\n        no_data_value=no_data_value,\n    )\n</code></pre>"},{"location":"reference/rasterra/_plotting/","title":"_plotting","text":""},{"location":"reference/rasterra/_plotting/#rasterra._plotting.Plotter","title":"<code>Plotter</code>","text":"Source code in <code>src/rasterra/_plotting.py</code> <pre><code>class Plotter:\n    def __init__(\n        self,\n        data: RasterData,\n        data_mask: RasterMask,\n        transform: affine.Affine,\n    ) -&gt; None:\n        self._data = data\n        self._mask = data_mask\n        self._transform = transform\n\n    def __call__(\n        self,\n        ax: Axes | None = None,\n        cmap: str | Colormap = \"viridis\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        under_color: str | None = None,\n        no_data_color: str | None = None,\n        norm: Normalize | None = None,\n        *,\n        colorbar: bool = True,\n        **kwargs: Any,\n    ) -&gt; Axes:\n        if (vmin is not None or vmax is not None) and norm is not None:\n            msg = \"Cannot pass both vmin/vmax and norm.\"\n            raise ValueError(msg)\n        if norm is None:\n            norm = Normalize(vmin=vmin, vmax=vmax)\n\n        kwargs[\"extent\"] = plotting_extent(self._data, self._transform)\n\n        show_plt = False\n        if not ax:\n            show_plt = True\n            ax = plt.gca()\n\n        _make_image_plot(\n            data=self._data,\n            mask=self._mask,\n            norm=norm,\n            cmap=cmap,\n            under_color=under_color,\n            no_data_color=no_data_color,\n            colorbar=colorbar,\n            ax=ax,\n            **kwargs,\n        )\n\n        if show_plt:\n            plt.show()\n\n        return ax\n\n    def test_normalization(\n        self,\n        norm: Normalize,\n        nbins: int = 50,\n        cmap: str | Colormap = \"viridis\",\n        under_color: str | None = None,\n        no_data_color: str | None = None,\n    ) -&gt; None:\n        \"\"\"Test a normalization of the data for plotting.\"\"\"\n        vmin = norm.vmin if norm.vmin is not None else self._data.min()\n        vmax = norm.vmax if norm.vmax is not None else self._data.max()\n        mask = (vmin &lt;= self._data) &amp; (self._data &lt;= vmax) &amp; ~self._mask\n        data = self._data[mask].flatten()\n\n        result = norm(data)\n\n        fig, axes = plt.subplots(figsize=(15, 15), ncols=2, nrows=2)\n\n        _make_hist_plot(\n            data=data,\n            nbins=nbins,\n            title=\"Raw data\",\n            ax=axes[0, 0],\n        )\n        _make_image_plot(\n            data=data,\n            mask=self._mask,\n            norm=Normalize(vmin=vmin, vmax=vmax),\n            cmap=cmap,\n            under_color=under_color,\n            no_data_color=no_data_color,\n            colorbar=False,\n            ax=axes[1, 0],\n        )\n\n        _make_hist_plot(\n            data=result,\n            nbins=nbins,\n            title=\"Normalized data\",\n            ax=axes[0, 1],\n        )\n        _make_image_plot(\n            data=result,\n            mask=self._mask,\n            norm=norm,\n            cmap=cmap,\n            under_color=under_color,\n            no_data_color=no_data_color,\n            colorbar=False,\n            ax=axes[1, 1],\n        )\n\n        plt.show()\n</code></pre>"},{"location":"reference/rasterra/_plotting/#rasterra._plotting.Plotter.test_normalization","title":"<code>test_normalization(norm: Normalize, nbins: int = 50, cmap: str | Colormap = 'viridis', under_color: str | None = None, no_data_color: str | None = None) -&gt; None</code>","text":"<p>Test a normalization of the data for plotting.</p> Source code in <code>src/rasterra/_plotting.py</code> <pre><code>def test_normalization(\n    self,\n    norm: Normalize,\n    nbins: int = 50,\n    cmap: str | Colormap = \"viridis\",\n    under_color: str | None = None,\n    no_data_color: str | None = None,\n) -&gt; None:\n    \"\"\"Test a normalization of the data for plotting.\"\"\"\n    vmin = norm.vmin if norm.vmin is not None else self._data.min()\n    vmax = norm.vmax if norm.vmax is not None else self._data.max()\n    mask = (vmin &lt;= self._data) &amp; (self._data &lt;= vmax) &amp; ~self._mask\n    data = self._data[mask].flatten()\n\n    result = norm(data)\n\n    fig, axes = plt.subplots(figsize=(15, 15), ncols=2, nrows=2)\n\n    _make_hist_plot(\n        data=data,\n        nbins=nbins,\n        title=\"Raw data\",\n        ax=axes[0, 0],\n    )\n    _make_image_plot(\n        data=data,\n        mask=self._mask,\n        norm=Normalize(vmin=vmin, vmax=vmax),\n        cmap=cmap,\n        under_color=under_color,\n        no_data_color=no_data_color,\n        colorbar=False,\n        ax=axes[1, 0],\n    )\n\n    _make_hist_plot(\n        data=result,\n        nbins=nbins,\n        title=\"Normalized data\",\n        ax=axes[0, 1],\n    )\n    _make_image_plot(\n        data=result,\n        mask=self._mask,\n        norm=norm,\n        cmap=cmap,\n        under_color=under_color,\n        no_data_color=no_data_color,\n        colorbar=False,\n        ax=axes[1, 1],\n    )\n\n    plt.show()\n</code></pre>"},{"location":"reference/rasterra/_typing/","title":"_typing","text":""}]}